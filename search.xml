<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ooUnit2</title>
      <link href="/2025/04/14/ooUnit2/"/>
      <url>/2025/04/14/ooUnit2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于面向对象多线程电梯那些事"><a href="#关于面向对象多线程电梯那些事" class="headerlink" title="关于面向对象多线程电梯那些事"></a>关于面向对象多线程电梯那些事</h1><p>写在前面：经历面向对象第二单元作业的这三周后，我对于多线程电梯的评价是很好的。这次作业给了我们机会去尝试多线程编程，能实际面临并解决多线程的资源竞争和线程安全问题。对我个人来说，我体会了多线程的复杂与神奇所在，在写每一个独立线程时需要时刻保持警惕，要把其它线程想象为一个陌生的程序员，保护自己的工作逻辑不受其它线程的破坏。</p><h2 id="Unit2三次作业感受"><a href="#Unit2三次作业感受" class="headerlink" title="Unit2三次作业感受"></a>Unit2三次作业感受</h2><p>个人感觉其实第一次作业是最难的，是因为第一次面临多线程设计是最不熟悉的，好在practice3给了我很大的启发和帮助。而第二次和第三次作业则相对简单了很多（不写影子电梯的话）。<br><img src="/../images/%E6%B5%81%E7%A8%8B.png" alt="流程"></p><h3 id="多线程协作与锁的选择"><a href="#多线程协作与锁的选择" class="headerlink" title="多线程协作与锁的选择"></a>多线程协作与锁的选择</h3><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p><img src="/../images/hw5.png" alt="hw5"><br>第一次作业需要设计三种线程，分别是InputHandler（输入处理），Dispatcher（请求分派）和elevator（电梯）；两类共享资源RequestTable（请求总表）和WaitTable（电梯等待队列）。这三种线程两种共享资源构成了两对生产者消费者模型。</p><p>InputHandler线程的逻辑非常简单，就是利用官方包从stdin读入数据并解析请求类型，第一次作业只有PersonRequest，所以InputHandler就只需考虑将请求信息封装为一个对象Person（方便后续电梯中途下人并重新分配电梯），然后作为生产者将Person投喂给RequestTable即可。</p><p>RequestTable作为共享资源，所要面临的是InputHandler的写入和Dispatcher的读出。对于InputHandler提供offer()方法，对Dispatcher提供poll()方法，同时设置一系列RequestTable的状态查询方法（如是否结束或者是否为空，以便所有请求都处理后线程都能正常结束）。荣老师在课上说对对象的方法上synchronized修饰上锁是不合适的，究其原因在于要最小化一个原子操作（待会解释什么是一个原子操作）。但是考虑到RequestTable方法本身非常简单，给方法修饰synchronized反而可能更安全。<br>对于共享资源的保护，我们提及了synchronized修饰符和原子操作这个概念，所谓原子操作，通俗一点的解释就是某一个线程的操作是不可被其它线程插入并修改共享资源从而改变运行逻辑的操作就是一个原子操作，就像原子是物质的基本组成粒子，不可再分（化学层面 :））。理解了原子性这个概念后，我们对于线程安全问题就能更上一层楼了。</p><p>Dispatcher设计或许在这一次作业里没那么重要，但是其存在为后续的非指派的分派算法设计提供了空间。当RequestTable非空时，Dispatcher从总表poll()一个请求，并按照设定的算法分派给对应电梯的WaitTable即可。为避免轮询白白占用cpu资源，我们需要让Dispatcher在RequestTable在为空但是未结束时“睡一会”，这里的“睡一会”并非真的睡觉（sleep），而是调用RequestTable.wait()进入RequestTable的等待队列。<br>这里又会涉及到一个新的概念：wait-notify。Dispatcher会先判断RequestTable的状态并决定是否进入RequestTable的等待队列，这里有两个点需要注意：</p><ol><li>Dispatcher需要分别查询RequestTable是否为空和是否结束，虽说是两次查询，但我们需要将这次行为作为一次原子操作，不然在第一次和第二次查询之间很有可能有其它线程抢走RequestTable的锁并改变了RequestTable的状态导致Dispatcher的逻辑错误。</li><li>为了避免死锁，我们需要在每一次改变共享对象的状态后调用notifyAll()将所有的处于共享对象的等待队列的线程唤醒，但是这个唤醒是无条件的，所以可能存在“假醒”的存在。所以我们需要将wait块包装在while(true)块内，唤醒后再一次查询资源状态，只有满足条件才会真的被唤醒。</li></ol><p>WaitTable同样作为共享资源，其所设计的逻辑和RequestTable是大差不差的，要为Dispatcher提供offer()方法，要为电梯提供poll()方法，内部维护的是分派给对应电梯的Person。</p><p>Elevator作为另一个消费者，其逻辑是根据WaitTable的状态和自身的决策算法，不断选择一定的运动，如移动，载人，放人，等待和结束。</p><p>第一次作业到此就结束了，虽然理清逻辑后觉得很简单，但是多线程编程设计时每写一句可能就需要考虑会不会造成线程冲突和不安全问题，会不会造成死锁问题。</p><h4 id="第二次作业与第三次作业"><a href="#第二次作业与第三次作业" class="headerlink" title="第二次作业与第三次作业"></a>第二次作业与第三次作业</h4><p><img src="/../images/hw6.png" alt="hw6"><br>第二次作业主要的改动有：</p><ol><li>不再提前指定请求分派的电梯，需要Dispatcher通过设计dispatch算法为请求分派请求。</li><li>新增SCHE特殊调度，并且这个调度的优先级很高，需要让电梯尽快的响应。</li></ol><p>这一次作业我觉得有几点设计是值得说一说的：</p><ol><li>将电梯属性和动作全部转至WaitTable维护，电梯本身抽象为一个纯粹的线程，只是不断的调用WaitTable的状态转移函数；电梯属性和电梯动作抽象为WaitTable的数据和属性改变和查询的方法。这么做虽然会大大增加WaitTable的复杂度，但是为外部设计带来了很多便利：<ul><li>Dispatcher设计dispatch算法时避免不了需要同时掌握等待队列和电梯的信息，然后决定分派给谁，当把电梯的属性转至WaitTable统一维护时，Dispatcher就只需要和WaitTable进行交互，同时也能提高电梯数性的安全性，避免了对于电梯属性的数据冲突。</li></ul></li><li>“围师必阙”：这一点设计我其实参考的是讨论区里助教的设计，注意到当电梯进入特殊调度状态时，就不能receive请求了，那如果某段时间只有一个电梯可用，同时这段时间来了大量的请求，如果分派算法设计的不好的话很有可能会把所有的请求都分派给“劳模电梯”，导致运行时间大大增加。那我们怎么解决这个问题呢，我们可以采用缓冲机制（Buffer），讨论区的助教可能是为了设计影子电梯分派算法而设计的这个机制，但是我发现其适用性非常广，于是便吸收进来化为己用。所谓缓冲机制，就是在WaitTable里设置另外一个容器，当Dispatcher决定将某一个请求分派给某一个电梯时，而此时电梯处于特殊调度状态，我们不直接把这个请求“分”给这个电梯，而是把这个请求放进这个特殊的容器，当电梯结束特殊调度状态时自动的把这个容器全部正式接收。</li><li>引入单例模式和多例模式。注意到在设计的过程中，经常需要访问其它对象，在这次作业里频次格外的高，但是把对象作为一个方法的参数传入的话实在不美观，于是我引入了单例模式和工厂模式。注意到RequestTable有且只有一个，电梯和与其对应的WaitTable存在6个。所以我把RequestTable设计为单例模式，把电梯和WaitTable设计为多例模式。其在程序创立之初就已经被静态的创建和存储在对应的Factory里，所以在需要访问某一个对象时就只需要向对应的静态Factory里请求即可。</li></ol><p>这里作业还有一个关于原子操作方面的点值得注意，与第一次作业不同的是，RequestTable还有可能会接受来自电梯的在分派请求，所以RequestTable是否结束的标准改为是否所有的请求都已经完成了，所以电梯在获得等待建议和执行wait进入WaitTable的等待队列的过程中需要保持为一个原子操作，否则，当最后一个电梯完成最后一个请求时，倘若Dispatcher线程插入，为WaitTable设为结束，但是当电梯重新拿回WaitTable的锁时，仍然会调用wait而不是结束线程，这时这个线程就会自此长睡不起了。</p><p><img src="/../images/hw7.png" alt="hw7"><br>第三次作业主要的改动有：</p><ol><li>新增双轿厢电梯，对应UPDATE请求。</li></ol><p>这次作业有两类设计是值得一说的：</p><ol><li>首先是线程同步机制，需要在UPDATE-begin和UPDATE-end进行两次同步，我采用了多例模式和CyclicBarrier结合的形式。我为每一对电梯都创建了实例化了一个CyclicBarrier，并存储在BarrierFactory里，在update的过程中，两个电梯通过同一个CyclicBarrier来进行同步。</li><li>关于双轿厢的设计，我自认为我的设计是比较简洁的。首先是结束UPDATE-end后，我不改变线程数量，仍然认为电梯处于自己的电梯井中，只是限制了其最高楼层和最低楼层，然后对于共享楼层的访问，设立了一个新的类SharedFloor，当电梯需要进入该楼层时，会向SharedFloor申请；当离开楼层时会“释放”该共享楼层的所有。同时要静止电梯在共享楼层等待从而长久的占用共享楼层。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class SharedFloor &#123;<br>    private boolean isOccupied = false;  // 标记是否被占用<br><br>    public synchronized void acquire() throws InterruptedException &#123;<br>        while (isOccupied) &#123;<br>            // 如果已被占用，线程进入等待状态<br>            wait();<br>        &#125;<br>        isOccupied = true;<br>    &#125;<br><br>    public synchronized void release() &#123;<br>        isOccupied = false;<br>        notifyAll(); // 唤醒所有等待的线程<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h3><h4 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h4><p>关于电梯的运作算法主要可能有ALS、SCAN、LOOK等，其实我个人在SCAN与LOOK中纠结了一下，但是鉴于往年学长统一的选择LOOK算法，我想这肯定是有道理的，便下定决心选择实现LOOK算法。</p><p>下面简单介绍一下LOOK算法：</p><ul><li>假定电梯处于某一层，且有一个特定的方向。</li><li>首先判断是否需要开门<ul><li>有人需要在该楼层下电梯</li><li>有人需要在该楼层进电梯</li></ul></li><li>然后判断电梯内部是否为空<ul><li>若不为空则往当前方向前进一步</li><li>再判断电梯是否有请求<ul><li>若电梯前方有请求则往当前运作方向前进一步</li><li>若电梯前方无请求则转向</li><li>若无请求则电梯进入睡眠状态</li></ul></li></ul></li></ul><p>所以getAdvice需要访问WaitTable维护的属性来确定电梯的下一步运作，所以在最外层套上对waitTable的synchronized块，实现代码大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Advice getAdvice() throws InterruptedException &#123;<br>        synchronized (this) &#123;<br>            if (sche != null) &#123;<br>                return Advice.SCHE;<br>            &#125;<br>            if (update != null) &#123;<br>                return Advice.UPDATE;<br>            &#125;<br><br>            if ((beRequested(floor, direction) &amp;&amp; inside.size() &lt; space) || canOut()) &#123;<br>                return Advice.OPEN;<br>            &#125; else if (!inside.isEmpty()) &#123;<br>                return Advice.MOVE;<br>            &#125; else &#123;<br>                if (isEmpty()) &#123;<br>                    if (isEnd()) &#123;<br>                        return Advice.END; //如果输入结束，电梯线程结束<br>                    &#125; else &#123;<br>                        if (sharing &amp;&amp; floor == transfer) &#123;<br>                            if (floor == top) &#123;<br>                                if (direction &gt; 0) &#123;<br>                                    return Advice.REVERSE;<br>                                &#125; else &#123;<br>                                    return Advice.MOVE;<br>                                &#125;<br>                            &#125; else if (floor == base) &#123;<br>                                if (direction &lt; 0) &#123;<br>                                    return Advice.REVERSE;<br>                                &#125; else &#123;<br>                                    return Advice.MOVE;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        this.wait();<br>                        return Advice.WAIT; //如果输入未结束，电梯线程等待<br>                    &#125;<br>                &#125; else &#123;<br>                    if (requestFront(floor, direction)) &#123;<br>                        return Advice.MOVE; //如果有请求发出地在电梯“前方”，则当前方向移动一层<br>                    &#125; else &#123;<br>                        return Advice.REVERSE; //电梯转向,不移动<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Dispatcher分派策略"><a href="#Dispatcher分派策略" class="headerlink" title="Dispatcher分派策略"></a>Dispatcher分派策略</h4><p>早已在刚进入计算机学院之处就听闻了影子电梯的大名，但是影子电梯需要同时获得六把锁，实现起来具有很大的风险，遂放弃，转而实现了随机分派策略。</p><p>随机分牌策略就是每一次分派时等可能的获得所想分派的电梯的id，然后仅需获得该电梯对应的WaitTable即可。但是在第二次和第三次作业中，电梯有可能处于特殊状态导致不能被分派，此时我们如果把所有请求分给空闲的电梯很有可能导致运行时间过长，为了解决这个问题让随机分派策略依然能进行下去，我设计了一种缓冲机制。</p><p>所谓缓冲机制，就是在电梯处于特殊状态时，不立即让这个电梯receive，而是存储在WaitTable的Buffer内，当电梯结束特殊状态后将Buffer清空并全部正式存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public synchronized void addBuffer(Person person) &#123;<br>     buffer.add(person);<br> &#125;<br> <br>synchronized (this) &#123;<br>        upDating = false;<br>        update = null;<br>        for (Person person : buffer) &#123;<br>            offer(person);<br>        &#125;<br>        buffer = new ArrayList&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DeBug方法"><a href="#DeBug方法" class="headerlink" title="DeBug方法"></a>DeBug方法</h2><h3 id="评测机的搭建"><a href="#评测机的搭建" class="headerlink" title="评测机的搭建"></a>评测机的搭建</h3><p>出于前几次作业没有做好评测而导致强测爆炸的惨痛经历，我在这单元充分的请教了D老师和G老师，将题目的指导书作为prompt，同时加入自己对于评测机的设计的思路，最终设计出了一个自动随机测试程序，遂用在了互测上，自动化评测房间里的同学，当出问题时就将对应的stdin和stdout信息保存下来，方便后续hack。</p><h3 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h3><p>光有评测机是远远不够的，处于多线程的随机性和无法调试性，我们很难直接从一般的输入输出信息发现自己程序的bug。受评论区大佬的启发，我单独开了一个DeBug类，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class DeBug &#123;<br>    public static boolean d() &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在程序中每个关键节点输出日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (DeBug.d()) &#123;<br>     System.out.println(&quot;[Log] + 相关信息&quot;))<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察日志信息，就让我发现了我在上文提到的最后一个电梯无法结束的bug，我发现日志没有所有电梯的end信息，便迅速察觉到了这个bug并立即做了修复。</p><h2 id="日后谈"><a href="#日后谈" class="headerlink" title="日后谈"></a>日后谈</h2><p>在三次作业中，我逐渐加深了对线程安全的理解和实践：</p><ul><li>理解原子操作与synchronized的使用场景：起初通过简单地给方法加 synchronized 来实现互斥，后来意识到应该精细控制锁的粒度，只在必要的代码块加锁，避免造成性能浪费。</li><li>掌握了wait-notify机制：在生产者消费者模型中，用 wait() 和 notifyAll() 控制线程的唤醒与阻塞，尤其注意了在循环中使用 wait 防止“假唤醒”问题。</li><li>避免死锁与线程长时间阻塞：在设计过程中不断检查线程可能卡死的点，像是线程 wait 后永远不被唤醒、或者电梯“长睡不起”等，尽量做到每一个线程都能有序启动与结束。</li><li>共享资源访问保护：每次访问共享数据结构如请求队列、缓冲区等都考虑到了线程竞争，并通过锁机制保证数据一致性。</li></ul><p>随着作业难度的提升，我也逐步建立起了模块化和分层的编程习惯：</p><ul><li>将电梯与调度逻辑解耦：电梯线程只负责执行动作，调度决策交给外部管理，使逻辑更清晰，便于扩展。</li><li>引入工厂模式和单例模式：将一些全局对象（如请求表）做成单例，把多个电梯或资源用工厂统一管理，避免重复创建，提高代码可维护性。</li><li>采用缓冲机制与共享区抽象：例如在 UPDATE 和 SCHE 等特殊状态下加入缓冲队列，保证调度器分派灵活不冲突；设计 SharedFloor 类集中管理共享楼层的进入与退出，简化了双轿厢访问控制。</li><li>输出日志与自测工具：为每一个模块加上日志输出、设计评测机进行压力测试，帮助在复杂的多线程环境中快速定位问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit1</title>
      <link href="/2025/03/20/ooUnit1/"/>
      <url>/2025/03/20/ooUnit1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>oo第一单元的任务是表达式括号展开与化简，课程组的目的在于通过这一十分结构化的任务来把我们引入面向对象的设计思想，并设计了三次迭代作业开发，旨在模拟真实的作业环境。</p><p>这一个月以来，确实在oo这门课上吃了不少苦，但通过自己的努力从第一次作业进C组到第三次作业强测无bug，互测只有一个bug，也学到了一些东西。通过这篇博客，本人将对自己的这三次代码进行详细分析，并做一些总结。</p><h1 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h1><p>第一次作业是对单变量（x）的多项式的展开。</p><h2 id="UML类图与架构设计"><a href="#UML类图与架构设计" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>本次作业代码的UML图如下</p><p><img src="/../images/hw1.jpg" alt="hw1"></p><h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><h3 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h3><p>这部分内容比较简单，我们沿用pre中hw7递归下降的做法，首先将<code>Input</code>传给<code>Lexer</code>，在<code>Lexer</code>建立的过程中，就完成了对各种符号的特异提取以及对变量（这里只有<code>x</code>）和数字的识别，并存储为一个<code>Token</code>串。然后将建立好的<code>Lexer</code>传递给<code>parser</code>。</p><p>我们第一次听说递归下降的时候可能会感到有些陌生。递归下降，在这里就是通过层层递归调用来完成对字符串<code>Input</code>的结构化建树，代码逻辑和建树的过程一致，自顶向下的建立好每一个分支。</p><p>我们这里需要建立的就是一个<code>Expression</code>的树，根节点是一个<code>Expr</code>，它由若干个子节点<code>Term</code>相加表述而成。同理，<code>Term</code>由若干个<code>Factor</code>相乘表述而成，若<code>Factor</code>是<code>Num</code>或者<code>Var</code>则递归到了终点，若为<code>ExprFactor</code>(一种特殊的<code>Factor</code>,内容是一个<code>Expr</code>)则跳到对<code>Expr</code>的解析。</p><p>所以代码中递归下降的核心就在于<code>parser</code>的<code>parseExpr()</code>中。</p><p>调用这个函数后会返回一个建立好的<code>Expr</code>，并交给下一步处理。</p><h3 id="括号展开"><a href="#括号展开" class="headerlink" title="括号展开"></a>括号展开</h3><p>这部分是本次作业的难点，我们需要将表达式展开为如下形式：</p><p>$$ E &#x3D; \sum ax^i $$</p><p>我们不难发现，这种形式的最小单元是一个单项式，于是我们建立<code>MiniTerm</code>类来描述这个最小单元（事实上一开始的实现并不好，代码结构混乱，也导致了很多的bug，我将在后面重构整个代码结构，但是大致的思路没什么问题）。<br>我们在类内部实现MiniTerm的乘法和加法的化简，来实现对括号的展开，由于会重构的原因，代码展示会放在后面的部分。</p><h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><h3 id="表达式解析-1"><a href="#表达式解析-1" class="headerlink" title="表达式解析"></a>表达式解析</h3><p>本部分沿用了pre的代码，这里就不再展开了。</p><h3 id="括号展开-1"><a href="#括号展开-1" class="headerlink" title="括号展开"></a>括号展开</h3><h4 id="重构前"><a href="#重构前" class="headerlink" title="重构前"></a>重构前</h4><p>其实可以发现在重构前，可以发现我的代码有两个主要的问题：</p><ul><li>Expr、Term和Factor内部的属性其实并不是真正的private的，存在大量的get方法将他们暴露在外，也导致了我的不良的代码结构和很多的bug。</li><li>建类混乱，没有清晰的层次结构。</li></ul><p>如，我对于展开后的表达式的结构化没有表示的很好，只有一个简单的最小单元类，事实上应该有一个多项式类来管理多项式乘法，将其与单项式加法区分开。</p><h4 id="重构后"><a href="#重构后" class="headerlink" title="重构后"></a>重构后</h4><p>首先是我重构后的UNL类图：</p><p><img src="/../images/hw1_re.png" alt="hw1_re"></p><p>可以发现，我对于解析包做了保留，主要在化简包上做了工作。</p><p>首先，我建立了一个静态的类<code>Simplifier</code>，它内部的函数<code>simplifyExpr(Expr expr)</code>会将传进来的expr按层次解析：</p><pre><code>public static Poly simplifyExpr(Expr expresiton) &#123;    Poly result = new Poly();    for (int i = 0; i &lt; expresiton.amount(); i = i + 1) &#123;        Term term = expresiton.getTerm(i);        Poly termPoly = simplifyTerm(term);        result = Poly.addPoly(result, termPoly);    &#125;    return result;&#125;public static Poly simplifyTerm(Term term) &#123;    Poly result = new Poly();    for (int i = 0; i &lt; term.amount(); i = i + 1) &#123;        Factor factor = term.getFactor(i);        Poly factorPoly = simplifyFactor(factor);        result = Poly.multPoly(result, factorPoly);    &#125;    return result;&#125;public static Poly simplifyFactor(Factor factor) &#123;    return factor.toPoly();&#125;</code></pre><p>把解析的过程完全脱离于其他工作，代码结构清晰了不少。</p><p>我们可以发现在<code>simplifyFactor(Factor factor)</code>调用了<code>toPoly()</code>方法，这就要引入我们的Poly类了。<br>主要属性如下：</p><pre><code>private HashMap&lt;Unit, BigInteger&gt; units;private ArrayList&lt;Unit&gt; flag;</code></pre><p>其中units用来储存这次作业的最小单元：单项式和对于的幂；flag用来储存units中的Key，主要作用是在后期取值时保护属性不暴露在外，也方便索引unit。</p><p>然后我们在Poly中实现了对Unit的加法：</p><pre><code>public void addUnit(Unit m, BigInteger c) &#123;    Unit newM = m.check();    if (units.containsKey(newM)) &#123;        BigInteger coe = units.get(newM);        coe = coe.add(c);        if (coe.equals(BigInteger.ZERO)) &#123;            units.remove(newM);            flag.remove(newM);            if (!units.containsKey(Unit.ONE)) &#123;                units.put(Unit.ONE, BigInteger.ZERO);//保留常数项                flag.add(Unit.ONE);            &#125;        &#125;        units.replace(newM, coe);    &#125; else &#123;        units.put(newM, c);        flag.add(newM);    &#125;&#125;</code></pre><p>还实现了对Poly的乘法和加法：</p><pre><code>public static Poly multPoly(Poly poly1, Poly poly2) &#123;    if (poly1.amount() == 0) &#123;        return poly2;    &#125;    if (poly2.amount() == 0) &#123;        return poly1;    &#125;    Poly result = new Poly();    for (Unit unit1 : poly1.units.keySet()) &#123;        for (Unit unit2 : poly2.units.keySet()) &#123;            //...        &#125;    &#125;    return result;&#125;public static Poly addPoly(Poly poly1, Poly poly2) &#123;    Poly result = new Poly();    for (Unit unit : poly1.units.keySet()) &#123;        result.addUnit(unit, poly1.units.get(unit));    &#125;    for (Unit unit : poly2.units.keySet()) &#123;        result.addUnit(unit, poly2.units.get(unit));    &#125;    return result;&#125;</code></pre><p>在以上的运算中始终保持最终的返回结果是最简的。</p><p>这样之后，我们就可以在Factor中每一个类都写一个toPoly方法，并层层向上传递，当传到顶层的时候就构建好了我们所需要的没有括号的表达式结构了。</p><p>这次重构给我带来的感受很多，主要有以下几点：</p><ul><li>不要为了优化代码量和代码性能而丧失代码的结构性和可读性。</li><li>对于一个类的内容的处理要在对应的类中写一个方法来实现，并返回最终的结果。这样既减少了代码的耦合性，又增加了代码的可读性。</li></ul><h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><h2 id="UML类图与架构设计-1"><a href="#UML类图与架构设计-1" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>如下：</p><p><img src="/../images/hw2.png" alt="hw2"></p><h2 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>第二次作业新增的内容是括号嵌套、递归自定义函数和三角函数因子。</p><p>由于我在上一次作业已经实现了括号嵌套（ExprFactor递归到Expr）所以这次作业我将就三角函数因子和自定义递归函数的处理讲解。</p><h3 id="三角函数因子"><a href="#三角函数因子" class="headerlink" title="三角函数因子"></a>三角函数因子</h3><p>这部分内容比较简单，我们首先需要在Factor接口新增两个实现即可，分别是<code>SinFactor</code>和<code>CosFactor</code>，并实现其<code>toPoly()</code>方法。</p><p>其次需要改写<code>Unit</code>，新增如下属性</p><pre><code>private ArrayList&lt;Poly&gt; sinPolys;private HashMap&lt;Poly, BigInteger&gt; sinFactors;private ArrayList&lt;Poly&gt; cosPolys;private HashMap&lt;Poly, BigInteger&gt; cosFactors;</code></pre><p>并改写Poly和Unit的乘法加法逻辑即可，就可以完成三角函数因子这部分内容。</p><p>要注意的是三角函数因子内部存储的内容是因子。</p><h3 id="递归自定义函数"><a href="#递归自定义函数" class="headerlink" title="递归自定义函数"></a>递归自定义函数</h3><p>说实话，这部分内容花了我很大一部分心思，我初期苦恼于如何有效的存储自定义函数和调用自定义函数。</p><p>经过一天的思考后我的解决方案是沿用递归下降的思路遍历<code>Expr</code>树：</p><p>1.新建一个<code>Function</code>类，类内部的属性为：</p><pre><code>private final String name;//函数名private final ArrayList&lt;String&gt; paras;//形参列表private final BigInteger coeFunc1;//n-1项的系数private final ArrayList&lt;Expr&gt; paraFunc1; //n-1项的实参形式，用Expr储存private final BigInteger coeFunc2;//n-2项的系数private final ArrayList&lt;Expr&gt; paraFunc2; //n-2项的实参形式，用Expr储存private final Expr func0;//0项的形参表达式private final Expr func1;//1项的形参表达式private final Expr expression;//函数表达式</code></pre><p>2.新建一个静态<code>SolveFunc</code>类存储已经定义好的函数，用函数名索引<code>Function</code>存在HashMap中，处理传入的<code>Expr</code>，替换所有的<code>FuncFactor</code>后返回新的<code>Expr</code>。内部方法如下：</p><pre><code>public static Expr solveExpr(Expr expr) &#123;    Expr newExpr = new Expr();    for (int i = 0; i &lt; expr.amount(); i += 1) &#123;        Term term = expr.getTerm(i);        term = solveTerm(term);        newExpr.addTerm(term);    &#125;    return newExpr;&#125;public static Term solveTerm(Term term) &#123;    Term newTerm = new Term();    for (int i = 0; i &lt; term.amount(); i += 1) &#123;        Factor factor = term.getFactor(i);        newTerm.addFactor(solveFactor(factor));    &#125;    return newTerm;&#125;public static Factor solveFactor(Factor factor) &#123;    return factor.solveFunc();&#125;</code></pre><p>3.在所有<code>Factor</code>中实现对<code>FuncFactor</code>的处理，以实现替换书上的所有<code>FuncFactor</code>节点。</p><p>具体逻辑是遍历树上的每一个<code>Factor</code>节点，若遇上<code>FuncFactor</code>则调用<code>Function.call()</code>并传入该函数因子的信息，替换的逻辑中也沿用了<strong>递归下降</strong>的想法，先自顶向下构建好待替换的<code>Expr</code>(设计斐波那契递归,层层计算<code>n-1</code>项<code>Expr</code>和<code>n-2</code>项<code>Expr</code>然后相加返回到上一层)，然后包装成<code>ExprFactor</code>后放入<code>FuncFactor</code>的位置即可。<br>经过上述操作后，<code>Expr</code>没有了<code>FuncFactor</code>节点，传给<code>Simplifier</code>进行括号展开即可。</p><h2 id="Poly和Unit的新增内容"><a href="#Poly和Unit的新增内容" class="headerlink" title="Poly和Unit的新增内容"></a>Poly和Unit的新增内容</h2><p>本次作业的最小单元不再是 $ax^n$ 而是 $ ax^n\prod_{i}sin(Factor_i)\prod_{i}cos(Factor_i)$<br>所以我们只需要改写一下加法和乘法的逻辑保证依然在计算的过程中是最简的即可。</p><h1 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h1><h2 id="UML类图与架构设计-2"><a href="#UML类图与架构设计-2" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>如下：</p><p><img src="/../images/hw3.png" alt="hw3"></p><h2 id="代码架构分析-1"><a href="#代码架构分析-1" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>可以发现，第三次作业的UML类图相比较于第二次作业的UML类图几乎没什么改动，一方面是因为这次作业的新增内容只有求导因子和自定义普通函数，另一方面是因为在第一次重构后我的代码的架构的优良。<br>由此也是第一次尝到了架构好的甜处。</p><h2 id="自定义普通函数"><a href="#自定义普通函数" class="headerlink" title="自定义普通函数"></a>自定义普通函数</h2><p>由于上一次作业已经实现了自定义递归函数，那我们也可以把自定义普通函数归于此，只需要把它看作递归深度为0的自定义递归函数即可，call时直接返回储存的0项表达式。</p><h2 id="求导因子"><a href="#求导因子" class="headerlink" title="求导因子"></a>求导因子</h2><p>第一步和第二次作业一样，先增加求导因子实现Factor这个接口。我们不难发现，实现求导的过程其实和替换FuncFactor的过程是可以很相似的，我们只需要一样的遍历整个树，当发现求导因子时，就递归的构建起表达式即可，这部分实现，我们放在了DerFactor里，代码结构如下：</p><pre><code>//SolveDer内容public static Expr solveExpr(Expr expr) &#123;    Expr newExpr = new Expr();    for (int i = 0; i &lt; expr.amount(); i += 1) &#123;        Term term = expr.getTerm(i);        term = solveTerm(term);        newExpr.addTerm(term);    &#125;    return newExpr;&#125;public static Term solveTerm(Term term) &#123;    Term newTerm = new Term();    for (int i = 0; i &lt; term.amount(); i += 1) &#123;        Factor factor = term.getFactor(i);        newTerm.addFactor(solveFactor(factor));    &#125;    return newTerm;&#125;public static Factor solveFactor(Factor factor) &#123;    return factor.solveDer();&#125;//DerFactor内容@Overridepublic Factor solveDer() &#123;    Expr newExpr = SolveDer.solveExpr(expr);//先解决expr的dx    newExpr = (Expr) newExpr.derive(); // expr.derive返回的是表达式    return new ExprFactor(newExpr, coe, exp);&#125;</code></pre><p>然后这次作业就很简单的被我们完成了。（好耶！！</p><h1 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h1><p>很不幸，本人在Unit1出现了许多的bug，让我们来一一分析一下bug的原因。</p><h2 id="HW1"><a href="#HW1" class="headerlink" title="HW1"></a>HW1</h2><p>在上文我们已经说过，第一作业的bug大多因为架构的不合理和代码风格的差劲。</p><p>那么不合理之处在哪呢？<br>1.类之间的耦合度高，没有做到把任务分解简化，而是让同一块处理多个混合的任务，非常容易导致bug。<br>下面就是hw1改写前的一些代码指标：</p><p><img src="/../images/hw1_%E6%8C%87%E6%A0%871%20.png" alt="指标1"></p><p>从左至右分别为OCavg Ocmax WMC</p><p><img src="/../images/hw1_%E6%8C%87%E6%A0%872.png" alt="指标2"></p><p>从左至右分别为Cogc ec(G) iv(G) v(G)</p><p>我们可以很明显的看出计算类和主类在多个指标中出现了不合理的数值，这明显是有缺陷的。</p><p>而在重构之后：</p><p><img src="/../images/hw1re.png" alt="hw1_re_指标"></p><p>计算类的指标好了许多，直观上我们也能感受到代码架构上的清晰化。</p><h2 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a>hw2</h2><p>第二次作业的bug主要是因为一处遗漏而导致的meg恶行bug，在强测多个点都出现了这个bug，在bug修复中修好后就大部分通过了。</p><p>另外一小部分是在优化中出了问题，这告诉我们优化需谨慎！！！</p><p>下面是hw2的一些指标</p><p><img src="/../images/hw2_%E6%8C%87%E6%A0%87.png" alt="hw2_指标"></p><p><img src="/../images/hw1re.png" alt="hw2_指标"></p><h2 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a>hw3</h2><p>第三次作业的bug是因为一处笔误导致的bug，这里就不展开描述了。</p><p><img src="/../images/hw2_%E6%8C%87%E6%A0%87.png" alt="hw3_指标"></p><p><img src="/../images/hw1re.png" alt="hw3_指标"></p><p><img src="/../images/hw3_%E6%8C%87%E6%A0%87.png" alt="hw3_指标"></p><h2 id="指标展现的优点"><a href="#指标展现的优点" class="headerlink" title="指标展现的优点"></a>指标展现的优点</h2><p>首先我的代码的耦合程度相较于我身边的同学是比较低的，我将各个任务分散到不同的模块中，从string到Expr的转换，处理FuncFactor，处理DerFactor，构建多项式并输出都是由独立的模块负责，并且将来如果有新的因子和处理，我还可以通过增添新的模块来完成这个任务，我的代码也因此可读性很高，也十分方便定位bug。</p><h2 id="指标展现的缺点"><a href="#指标展现的缺点" class="headerlink" title="指标展现的缺点"></a>指标展现的缺点</h2><p>但是由于上面不断的增添模块，如果需求越来越多，我的代码量也会越来越多，这将变得不利于维护。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本单元的优化我做的比较简单，主要集中在三角函数的合并优化。<br>首先是合并同类项，我重写了Expr、Term和Factor的HashCode和equals方法，这使得我判断两个Unit是否是同样的变得很简单，只需要调用containsKey()判断是否已经在Poly里即可。</p><p>但是这样还有一个问题，就是如果sin或者cos内的factor正好相差一个-1的系数呢？这个问题要完全解决比较苦难，所以我选择根据sin或cos里Poly的第一个Unit的符号做判断，如果是负号，那我选择将负号提到外面，这样一来即没有增添很多的代码，又能大大提高同类项的识别与合并概率。</p><h1 id="发现别人程序bug所采用的策略"><a href="#发现别人程序bug所采用的策略" class="headerlink" title="发现别人程序bug所采用的策略"></a>发现别人程序bug所采用的策略</h1><p>在经历hw2的惨痛教训后（没有好好评测自己的代码），我决定自己搭建一台评测机（主要是请教ChatGpt老师和DeepSeek老师）我让生成式人工智能为我写了一份评测数据的生成脚本，然后交给我自己写的自动化对拍程序，将互测小组内的成员的代码去跑我生成的评测数据并进行对拍，将不一致的结果记录下来，然后为了避免是同质的Bug，选择帮他们修复并重新评测。<br>这就是我这次hack采取的策略，但是不足的是，生成评测数据的脚本不是很强，并没有为我测处太多的bug，但好在为我自己的强测带来了很多好处。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ul><li><strong>写代码前先思考</strong> ： 如果啥都没想好就开写代码，那么这段代码一定会重构。</li><li><strong>多看学长学姐博客</strong> ： 学习前人经验和优秀的架构是一种好习惯，有时还能启发自己的新思路。</li><li><strong>注意代码的可读性和可拓展性</strong> ：千万不要为了代码量和编写方便而放弃代码的可读性，同时，这次Unit1的迭代开发经验还启示我一定要注意可拓展性。</li><li><strong>写代码时多关注代码指标</strong> ： 如果你发现自己的耦合度或者什么其他指标超标时，那么你就需要改一改你的架构了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2025/03/20/%E5%BC%80%E7%AF%87/"/>
      <url>/2025/03/20/%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="哇咔咔"><a href="#哇咔咔" class="headerlink" title="哇咔咔"></a>哇咔咔</h2><p><img src="/../images/%E9%94%A6%E9%B2%A4.jpg" alt="锦鲤"></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $^%@#!~ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单的自我介绍"><a href="#简单的自我介绍" class="headerlink" title="简单的自我介绍"></a>简单的自我介绍</h2><p>一个爱摸鱼但是也想发paper的北航计算机学生。</p><h2 id="为什么开这个博客"><a href="#为什么开这个博客" class="headerlink" title="为什么开这个博客"></a>为什么开这个博客</h2><p>想记录一下自己的生活（总不能让自己存在的唯一证明是留在沙发上的屁股印吧）</p><h2 id="我的联系方式"><a href="#我的联系方式" class="headerlink" title="我的联系方式"></a>我的联系方式</h2><ul><li>个人邮箱：<a href="mailto:&#x4a;&#99;&#x68;&#49;&#x38;&#50;&#x39;&#x37;&#52;&#57;&#x39;&#x36;&#54;&#53;&#64;&#x62;&#117;&#97;&#x61;&#46;&#101;&#x64;&#x75;&#46;&#x63;&#x6e;">&#x4a;&#99;&#x68;&#49;&#x38;&#50;&#x39;&#x37;&#52;&#57;&#x39;&#x36;&#54;&#53;&#64;&#x62;&#117;&#97;&#x61;&#46;&#101;&#x64;&#x75;&#46;&#x63;&#x6e;</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
