<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>os_challenge_shell</title>
      <link href="/2025/06/25/os-challenge-shell/"/>
      <url>/2025/06/25/os-challenge-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="lab6-challenge-shell"><a href="#lab6-challenge-shell" class="headerlink" title="lab6_challenge_shell"></a>lab6_challenge_shell</h1><p>我选择做相对有趣且有大量前人经验可参考的shell。</p><p>主要实现步骤有：</p><ul><li>语法分析</li><li>相对路径</li><li>拓展指令</li><li>环境变量</li><li>输入优化</li><li>历史指令</li><li>反引号、追加重定向与条件执行。</li></ul><p>总共6个部分内容，我将在下面一一展开描述我的实现。</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>因为mos的初始代码写的不是很好，在经过一段的时间的深思熟虑后，决定进行重构，搭建自己的语法树。由于这部分内容和oo的第一单元很类似，再加上ai的帮助，最后也没有花很长时间就完成了。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>首先是词法分析部分，类型申明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 词法分析相关 */<br>typedef enum &#123;<br>    T_WORD, T_PIPE, T_SEMI, T_AND, T_OR,<br>    T_REDIR_IN, T_REDIR_OUT, T_REDIR_APP,<br>    T_BACKQUOTE_OPEN,T_BACKQUOTE_CLOSE,T_EOF<br>&#125; TokenType;<br><br>typedef struct &#123;<br>    TokenType type;<br>    char *value;<br>&#125; Token;<br><br>typedef struct &#123;<br>    char *input;<br>    size_t pos;<br>&#125; LexerState;<br><br>LexerState lexer;<br></code></pre></td></tr></table></figure><p>在shell中需要实现一行多指令、重定向、管道、条件执行和反引号，所以就先定义了WORD，PIPE,SEMI等Token种类，用以语法分析的时候区分不同的Token。</p><p>使用的时候先初始化lexer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void init_lexer(const char *input) &#123;<br>lexer.input = input;<br>lexer.pos = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在语法分析的时候每一次取一个Token出来分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 获取下一个 token，消费它；返回 Token 结构（value 若是 WORD 需 strdup，调用者负责 free）<br>void get_next_token(Token* t) &#123;<br>while (strchr(WHITESPACE, *(lexer.input + lexer.pos))) &#123;<br>lexer.pos ++ ;<br>&#125; // 跳过空白符<br>if (lexer.pos == strlen(lexer.input)) &#123;<br>t-&gt;type = T_EOF;<br>t-&gt;value = NULL;<br>return;<br>&#125; //读到EOF<br>char c = lexer.input[lexer.pos];<br>if (isWord(c)) &#123;<br>char value[MAX_COMMAND_LEN];<br>int len = handleLetter(value);<br>t-&gt;type = T_WORD;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += len;<br>&#125; else if (c == &#x27;&lt;&#x27;) &#123;<br>char value[2];<br>strcpy(value, &quot;&lt;&quot;);<br>t-&gt;type = T_REDIR_IN;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>&#125; else if (c == &#x27;&gt;&#x27;) &#123;<br>char nc = lexer.input[lexer.pos + 1];<br>if (nc == &#x27;&gt;&#x27;) &#123;<br>char value[3];<br>strcpy(value, &quot;&gt;&gt;&quot;);<br>t-&gt;type = T_REDIR_APP;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 2;<br>&#125; else &#123;<br>char value[2];<br>strcpy(value, &quot;&gt;&quot;);<br>t-&gt;type = T_REDIR_OUT;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>&#125;<br>&#125; else if (c == &#x27;|&#x27;) &#123;<br>char nc = lexer.input[lexer.pos + 1];<br>if (nc == &#x27;|&#x27;) &#123;<br>char value[3];<br>strcpy(value, &quot;||&quot;);<br>t-&gt;type = T_OR;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 2;<br>&#125; else &#123;<br>char value[2];<br>strcpy(value, &quot;|&quot;);<br>t-&gt;type = T_PIPE;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>&#125;<br>&#125; else if (c == &#x27;;&#x27;) &#123;<br>char value[2];<br>strcpy(value, &quot;;&quot;);<br>t-&gt;type = T_SEMI;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>&#125; else if (c == &#x27;&amp;&#x27;) &#123;<br>char value[3];<br>strcpy(value, &quot;&amp;&amp;&quot;);<br>t-&gt;type = T_AND;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 2;<br>&#125; else if (c == &#x27;=&#x27;) &#123;<br>char value[2];<br>strcpy(value, &quot;=&quot;);<br>t-&gt;type = T_WORD;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>&#125; else if (c == &#x27;`&#x27;) &#123;<br>        char value[2];<br>strcpy(value, &quot;`&quot;);<br>        if (backquote_num%2 == 0) &#123;<br>            t-&gt;type = T_BACKQUOTE_OPEN;<br>        &#125; else &#123;<br>            t-&gt;type = T_BACKQUOTE_CLOSE;<br>        &#125;<br>        backquote_num++;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>        //debugf(&quot;backquote!\n&quot;);<br>    &#125; else &#123;<br>debugf(&quot;not defined token!: %c\n&quot;, c);<br>&#125;<br><br>return t;<br>&#125;<br></code></pre></td></tr></table></figure><p>词法分析的主要内容就是这些，主要是方便语法分析时把注意力放在Token上而不是字符上，这也是比较标准的做法。</p><h3 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析"></a>语法分析</h3><p>首先我们定义好要用的节点数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// === AST 结构及节点类型声明 ===<br><br>// AST 节点类型<br>typedef enum &#123;<br>    NODE_COMMAND,    // 基本命令<br>    NODE_REDIR_IN,   // 重定向 &lt;<br>    NODE_REDIR_OUT,  // 重定向 &gt;<br>    NODE_REDIR_APP,  // 重定向 &gt;&gt;<br>    NODE_PIPE,       // 管道 |<br>    NODE_AND,        // &amp;&amp;<br>    NODE_OR,         // ||<br>    NODE_SEQUENCE,   // 分号 ; （语句序列）<br>    NODE_BACKQUOTE,  // 反引号 `<br>    // 若将来支持后台 &#x27;&amp;&#x27;、子 Shell (…)、条件判断等，可继续扩展枚举<br>&#125; ASTNodeType;<br><br>// AST 节点结构<br>typedef struct ASTNode &#123;<br>    ASTNodeType type;<br>    union &#123;<br>        // 对于命令节点<br>        struct &#123;<br>            char *argv[MAXARGS];  // argv 数组，大小 argc+1，最后一个为 NULL<br>            int argc;<br>            struct ASTNode *backquote;<br>            int backquote_index;<br>        &#125; command;<br>        // 对于重定向节点（child 表示要重定向的命令或子结构）<br>        struct &#123;<br>            struct ASTNode *child;<br>            char *filename; // malloc 保存的文件名<br>            int mode;       // open() 时的 flags，如 O_RDONLY、O_WRONLY|O_CREAT|O_TRUNC、O_WRONLY|O_CREAT|O_APPEND<br>        &#125; redirect;<br>        // 对于二元操作：PIPE, AND, OR, SEQUENCE<br>        struct &#123;<br>            struct ASTNode *left;<br>            struct ASTNode *right;<br>        &#125; binary;<br>    &#125;;<br>&#125; ASTNode;<br></code></pre></td></tr></table></figure><p>可以看到同样定义了节点种类，不同的种类在union中取不同的元素，同时又保持了统一性，个人认为是一个比较优雅的实现。</p><p>我们先明确一下语法树会长什么样子，下面是语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 根据 EBNF:<br>// line     ::= list<br>// list     ::= and_or ( &quot;;&quot; and_or )*<br>// and_or   ::= pipeline ( ( &quot;&amp;&amp;&quot; | &quot;||&quot; ) pipeline )*<br>// pipeline ::= command ( &quot;|&quot; command )*<br>// command  ::= WORD ( WORD | redirect )*<br>// redirect ::= &quot;&lt;&quot; WORD | &quot;&gt;&quot; WORD | &quot;&gt;&gt;&quot; WORD<br></code></pre></td></tr></table></figure><p>一行指令由一个list组成；</p><p>一个list由若干and_or和<code>;</code>组成；</p><p>and_or由若干pipeline和<code>||</code>或者<code>&amp;&amp;</code>组成；</p><p>pipeline由若干command和<code>|</code>组成；</p><p>command里面又可能存在重定向符号然后command的参数可能存在反引号。</p><p>所以我们根据在树中的结构简单的将可能的节点种类划分为了三类，分别是重定向、指令和二元节点。</p><p>然后是parse指令部分，根据语法和上面划分好的结构，我们自定向下的建树，第一层是parse_list:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Token current_token;<br><br>void next_token() &#123;<br>    get_next_token(&amp;current_token);<br>&#125;<br><br>ASTNode *parse_line() &#123;<br>    next_token();<br>    return parse_list();<br>&#125;<br><br>int accept_token(TokenType expect) &#123;<br>    if (current_token.type == expect) &#123;<br>        next_token();<br>        return 1;<br>    &#125;<br>    return 0;<br>&#125;<br><br>// 解析 list: 可能含分号<br>ASTNode *parse_list() &#123;<br>    ASTNode *left = parse_and_or();<br>    while (accept_token(T_SEMI)) &#123;<br>        ASTNode *right = parse_and_or();<br>        left = new_binary_node(NODE_SEQUENCE, left, right);<br>    &#125;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据分号的间隔解析成若干个and_or节点，并分别放到左节点和右节点。</p><p>比如：<code>ls;pwd;exit</code> 就解析成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">      root<br>     /    \ <br>  binary  exit <br> /      \<br>ls      pwd<br></code></pre></td></tr></table></figure><p>分号的下一层是条件执行，由<code>||</code>和<code>&amp;&amp;</code>分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 解析 and_or：处理 &amp;&amp; 和 ||<br>ASTNode *parse_and_or() &#123;<br>    ASTNode *left = parse_pipeline();<br>    while (current_token.type == T_AND || current_token.type == T_OR) &#123;<br>        ASTNodeType op = (current_token.type == T_AND) ? NODE_AND : NODE_OR;<br>        next_token();<br>        ASTNode *right = parse_pipeline();<br>        left = new_binary_node(op, left, right);<br>    &#125;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure><p>和分号都是binary节点，所以解析的步骤是一样的，只是分隔符不一样（while循环条件）。</p><p>条件执行的下一层是管道，和上面步骤也是一致的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 解析 pipeline：处理管道 |<br>ASTNode *parse_pipeline() &#123;<br>    ASTNode *left = parse_command();<br>    while (accept_token(T_PIPE)) &#123;<br>        ASTNode *right = parse_command();<br>        left = new_binary_node(NODE_PIPE, left, right);<br>    &#125;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure><p>管道下一层就是指令了，先看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 解析单一 command（命令和其参数、重定向）<br>ASTNode *parse_command() &#123;<br>    if (current_token.type != T_WORD) &#123;<br>        debugf(&quot;UnExpected command : %d, value : %s\n&quot;, current_token.type, current_token.value);<br>    &#125;<br><br>    char *argv[MAXARGS]; // 固定最大参数数<br>    int argc = 0;<br>    ASTNode *backquote_ast = NULL;<br>    int backquote_index = -1;<br><br>    while (current_token.type == T_WORD || current_token.type == T_BACKQUOTE_OPEN) &#123;<br>        if (current_token.type == T_WORD) &#123;<br>            argv[argc++] = current_token.value;<br>            next_token();   <br>        &#125; else &#123;<br>            next_token();<br>            backquote_ast = parse_list();<br>            if (!accept_token(T_BACKQUOTE_CLOSE)) &#123;<br>                debugf(&quot;parse back quote wrong!\n&quot;);<br>                exit();<br>            &#125;<br>            backquote_index = argc;<br>            argc++;<br>        &#125;<br>    &#125;<br>    argv[argc] = NULL;<br><br>    ASTNode *node = new_command_node(argv, argc, backquote_ast, backquote_index);<br><br>    // 处理重定向<br>    while (current_token.type == T_REDIR_IN ||<br>           current_token.type == T_REDIR_OUT ||<br>           current_token.type == T_REDIR_APP) &#123;<br>        node = parse_redirect(node);<br>    &#125;<br><br>    return node;<br>&#125;<br><br>// 解析重定向，前提当前 token 是 &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&gt;&gt;&quot;<br>ASTNode *parse_redirect(ASTNode *prev_cmd_node) &#123;<br>    ASTNodeType rtype;<br>    int mode;<br>    if (accept_token(T_REDIR_IN)) &#123;<br>        rtype = NODE_REDIR_IN;<br>        mode = O_RDONLY;<br>    &#125; else if (accept_token(T_REDIR_OUT)) &#123;<br>        rtype = NODE_REDIR_OUT;<br>        mode = O_WRONLY | O_CREAT | O_TRUNC;<br>    &#125; else if (accept_token(T_REDIR_APP)) &#123;<br>        rtype = NODE_REDIR_APP;<br>        mode = O_WRONLY | O_CREAT | O_APPEND;<br>    &#125; else &#123;<br>        return prev_cmd_node; // 非重定向<br>    &#125;<br>    if (current_token.type != T_WORD) &#123;<br>        debugf(&quot;Expected filename after redirection\n&quot;);<br>    &#125;<br>    char *filename = current_token.value;<br>    next_token();<br>    return new_redirect_node(rtype, prev_cmd_node, filename, mode);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于command的解析，此时已经处于解析的最底层，所以通过是否是Word来取出对应的Token，然后放进argv数组里，若此时出现了反引号Backquote_OPEN，则重新进入parse list， 解析出一条完整的指令后标记好后续应该放入argv的index。</p><p>然后处理重定向部分，判断下一个Token是不是重定向符号，若是则进入parse_redirect部分。</p><p>就这样，通过递归下降法，我们一层一层的剥离了一行指令的结构，构造好了自己的语法树。</p><p>然后还有一个小技巧需要说明一下，由于mos没有实现动态内存分配，但是我们的树和字符串又需要动态申请，怎么办呢？</p><p>针对这个问题我使用的方法是现在sh.c里静态申请好一个长字符串和足够数量的AST树节点，然后写了对应的分配函数，当需要的时候就取出空闲的部分，不用的时候释放即可。下面是关键代码部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\======= 字符串申请==========\\<br>static char pool[STRING_POOL_SIZE];<br>static int used[STRING_POOL_SIZE];  // 标记每个字节是否被使用<br><br>void reset_string_pool() &#123;<br>    memset(pool, 0, sizeof(pool));<br>    memset(used, 0, sizeof(used));<br>&#125;<br><br>char *alloc_string(const char *src) &#123;<br>    int len = strlen(src) + 1;  // 包括 &#x27;\0&#x27;<br>    if (len &gt; STRING_MAX_LEN) return NULL;<br><br>    for (int i = 0; i &lt;= STRING_POOL_SIZE - len; ++i) &#123;<br>        int found = 1;<br>        for (int j = 0; j &lt; len; ++j) &#123;<br>            if (used[i + j]) &#123;<br>                found = 0;<br>                i += j;  // 跳过当前已使用区<br>                break;<br>            &#125;<br>        &#125;<br>        if (found) &#123;<br>            // 找到足够连续空间<br>            memcpy(&amp;pool[i], src, len);<br>            for (int j = 0; j &lt; len; ++j) &#123;<br>                used[i + j] = 1;<br>            &#125;<br>            return &amp;pool[i];<br>        &#125;<br>    &#125;<br><br>    return NULL;  // 空间不足<br>&#125;<br><br>\\========== AST 节点申请 ===========\\<br>static ASTNode nodes[MAX_NODES];<br>static uint8_t bitmap[MAX_NODES / 8];  // 1024 bits = 128 bytes<br><br>// 设置 bitmap 中的第 i 位为 1<br>void set_bit(int i) &#123;<br>    bitmap[i / 8] |= (1 &lt;&lt; (i % 8));<br>&#125;<br><br>// 设置 bitmap 中的第 i 位为 0<br>void clear_bit(int i) &#123;<br>    bitmap[i / 8] &amp;= ~(1 &lt;&lt; (i % 8));<br>&#125;<br><br>// 检查 bitmap 中的第 i 位是否为 1（已分配）<br>int is_allocated(int i) &#123;<br>    return (bitmap[i / 8] &gt;&gt; (i % 8)) &amp; 1;<br>&#125;<br><br>// 自定义 malloc: 分配一个空闲的 ASTNode<br>ASTNode* alloc_ast_node() &#123;<br>    for (int i = 0; i &lt; MAX_NODES; ++i) &#123;<br>        if (!is_allocated(i)) &#123;<br>            set_bit(i);<br>            return &amp;nodes[i];<br>        &#125;<br>    &#125;<br>    return NULL;  // 没有空闲节点<br>&#125;<br><br>// 自定义 free: 回收指定的 ASTNode<br>void free_ast_node(ASTNode* node) &#123;<br>    int index = node - nodes;<br>    if (index &gt;= 0 &amp;&amp; index &lt; MAX_NODES) &#123;<br>        clear_bit(index);<br>    &#125;<br>&#125;<br><br>// 释放 AST 节点（递归释放子节点、argv 中字符串等）<br>void free_ast(ASTNode *node) &#123;<br>    if (!node) return;<br><br>    switch (node-&gt;type) &#123;<br>        case NODE_COMMAND:<br>            // 不释放 argv[i] 或 argv，只释放节点<br>            break;<br><br>        case NODE_REDIR_IN:<br>        case NODE_REDIR_OUT:<br>        case NODE_REDIR_APP:<br>            free_ast(node-&gt;redirect.child); // 递归释放子节点<br>            break;<br><br>        case NODE_PIPE:<br>        case NODE_AND:<br>        case NODE_OR:<br>        case NODE_SEQUENCE:<br>            free_ast(node-&gt;binary.left);<br>            free_ast(node-&gt;binary.right);<br>            break;<br><br>        default:<br>            break;<br>    &#125;<br><br>    // 释放当前节点到池中<br>    free_ast_node(node);<br>&#125;<br><br>ASTNode *new_command_node(char **argv, int argc, ASTNode* backquote, int backquote_index) &#123;<br>    ASTNode *node = alloc_ast_node();<br>    node-&gt;type = NODE_COMMAND;<br>int i;<br>    for(i = 0; argv[i] != NULL; i++) &#123;<br>node-&gt;command.argv[i] = argv[i];<br>&#125;<br>node-&gt;command.argv[i] = NULL;<br>    node-&gt;command.argc = argc;<br>    node-&gt;command.backquote = backquote;<br>    node-&gt;command.backquote_index = backquote_index;<br>    return node;<br>&#125;<br><br>ASTNode *new_redirect_node(ASTNodeType type, ASTNode *child, char *filename, int mode) &#123;<br>    ASTNode *node = alloc_ast_node();<br>    node-&gt;type = type;<br>    node-&gt;redirect.child = child;<br>    node-&gt;redirect.filename = filename;<br>    node-&gt;redirect.mode = mode;<br>    return node;<br>&#125;<br><br>ASTNode *new_binary_node(ASTNodeType type, ASTNode *left, ASTNode *right) &#123;<br>    ASTNode *node = alloc_ast_node();<br>    node-&gt;type = type;<br>    node-&gt;binary.left = left;<br>    node-&gt;binary.right = right;<br>    return node;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出我用的是位图法进行的空闲部分的管理，在申请的时候置位位图，在释放的时候置零位图即可。</p><h3 id="语法树执行"><a href="#语法树执行" class="headerlink" title="语法树执行"></a>语法树执行</h3><p>经过上面的折腾，我们已经按执行优先级解析完了我们指令的结构，下一步就是执行了，我们用深度优先搜索的方法对整棵树进行遍历即可，下面是关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 执行 AST，返回子命令退出状态或整体状态<br>int execute_ast(ASTNode *node, int in_subshell) &#123;<br>    if (!node) return 0;<br>    switch (node-&gt;type) &#123;<br>        case NODE_COMMAND:<br>            return exec_command_node(node, in_subshell);<br>        case NODE_PIPE:<br>            return exec_pipe_node(node, in_subshell);<br>        case NODE_AND:<br>            return exec_and_node(node, in_subshell);<br>        case NODE_OR:<br>            return exec_or_node(node, in_subshell);<br>        case NODE_SEQUENCE:<br>            return exec_sequence_node(node, in_subshell);<br>        case NODE_REDIR_IN:<br>        case NODE_REDIR_OUT:<br>        case NODE_REDIR_APP:<br>            return exec_redirection_node(node, in_subshell);<br>        default:<br>            debugf(&quot;Unsupported AST node type %d\n&quot;, node-&gt;type);<br>            return 1;<br>    &#125;<br>&#125;<br>//分派函数<br>int exec_command_node(ASTNode *node, int in_subshell) &#123;<br>    char **argv = node-&gt;command.argv;<br>    if (argv[0] == NULL) return 0;<br>    //处理反引号<br>    handleBackquote(node);<br>//处理变量<br>for (int i = 0; argv[i] != NULL; i++) &#123;<br>    replace_vars(argv[i]);<br>if (strlen(argv[i]) == 0) &#123;<br>for(int j = i; argv[j] != NULL; j++) &#123;<br>argv[j] = argv[j+1];<br>&#125;<br>i-=1;<br>&#125;<br>&#125;<br>    if (is_builtin(argv[0])) &#123;<br>        return run_builtin(argv);<br>    &#125; else &#123;<br>        int child = spawn(argv[0], argv);<br>if (child &gt;= 0) &#123;<br>wait(child);<br>&#125; else &#123;<br>debugf(&quot;spawn %s: %d\n&quot;, argv[0], child);<br>&#125;<br>        int r = syscall_get_last_call();<br>        return r;<br>&#125;<br><br>return 0;<br>&#125;<br><br>int exec_pipe_node(ASTNode *node, int in_subshell) &#123;<br>    int fds[2];<br>int r;<br>    if (r = pipe(fds) &lt; 0) &#123;<br>        user_panic(&quot;pipe : %d&quot;, r);<br>    &#125;<br>    int pid_left = fork();<br>    if (pid_left &lt; 0) &#123;<br>        user_panic(&quot;fork : %d&quot;, pid_left);<br>        close(fds[0]); <br>close(fds[1]);<br>        return 1;<br>    &#125;<br>    if (pid_left == 0) &#123;<br>        // 左侧子进程<br>        close(fds[0]);<br>        if (dup(fds[1], STDOUT_FILENO) &lt; 0) &#123;<br>            user_panic(&quot;dup&quot;); <br>exit();<br>        &#125;<br>        close(fds[1]);<br>        // 在子进程中执行左子 AST<br>        execute_ast(node-&gt;binary.left, 1);<br>        exit();<br>    &#125;<br>    int pid_right = fork();<br>    int result = 0;<br>    if (pid_right &lt; 0) &#123;<br>        user_panic(&quot;fork&quot;);<br>        // 关闭并等待左<br>        close(fds[0]); <br>close(fds[1]);<br>        wait(pid_left);<br>        return 1;<br>    &#125;<br>    if (pid_right == 0) &#123;<br>        // 右侧子进程<br>        close(fds[1]);<br>        if (dup(fds[0], STDIN_FILENO) &lt; 0) &#123;<br>            user_panic(&quot;dup&quot;);<br>exit();<br>        &#125;<br>        close(fds[0]);<br>        int result = execute_ast(node-&gt;binary.right, 1);<br>        exit();<br>    &#125;<br>    // 父进程<br>    close(fds[0]); <br>close(fds[1]);<br>    wait(pid_left);<br>wait(pid_right);<br>    <br>    return result;<br>&#125;<br><br>int exec_sequence_node(ASTNode *node, int in_subshell) &#123;<br>    // 左侧执行，忽略或记录状态<br>    execute_ast(node-&gt;binary.left, in_subshell);<br>    return execute_ast(node-&gt;binary.right, in_subshell);<br>&#125;<br><br>int exec_redirection_node(ASTNode *node, int in_subshell) &#123;<br>    int fd;<br>    handleBackquote(node-&gt;redirect.child);<br>    if (node-&gt;type == NODE_REDIR_IN) &#123;<br>        fd = open(node-&gt;redirect.filename, O_RDONLY);<br>        if (fd &lt; 0) &#123; <br>debugf(&quot;failed to open : %s\n&quot;, node-&gt;redirect.filename); <br>return 1; <br>&#125;<br>        if (dup(fd, STDIN_FILENO) &lt; 0) &#123; <br>debugf(&quot;dup error\n&quot;); <br>close(fd); <br>return 1; <br>&#125;<br>        close(fd);<br>    &#125; else if (node-&gt;type == NODE_REDIR_OUT) &#123;<br>        fd = open(node-&gt;redirect.filename, O_WRONLY | O_CREAT | O_TRUNC);<br>        if (fd &lt; 0) &#123; <br>debugf(&quot;open wrong : %s\n&quot;, node-&gt;redirect.filename); <br>return 1; <br>&#125;<br>        if (dup(fd, STDOUT_FILENO) &lt; 0) &#123; <br>debugf(&quot;dup error&quot;); <br>close(fd); <br>            return 1; <br>&#125;<br>        close(fd);<br>    &#125; else if (node-&gt;type == NODE_REDIR_APP) &#123;<br>        fd = open(node-&gt;redirect.filename, O_WRONLY | O_CREAT | O_APPEND);<br>        if (fd &lt; 0) &#123; <br>debugf(&quot;open wrong : %s\n&quot;, node-&gt;redirect.filename); <br>return 1; <br>&#125;<br>        if (dup(fd, STDOUT_FILENO) &lt; 0) &#123; <br>debugf(&quot;dup eooro\n&quot;); <br>close(fd); <br>return 1; <br>&#125;<br>        close(fd);<br>    &#125; else &#123;<br>        // 不应到达<br>        debugf(&quot;Unknown redirection type %d\n&quot;, node-&gt;type);<br>        return 1;<br>    &#125;<br>    // 设置完成后执行子节点<br>    return execute_ast(node-&gt;redirect.child, in_subshell);<br>&#125;<br><br>int exec_and_node(ASTNode *node, int in_subshell) &#123;<br>    int status = execute_ast(node-&gt;binary.left, in_subshell);<br>    if (status == 0) &#123;<br>        return execute_ast(node-&gt;binary.right, in_subshell);<br>    &#125;<br>    return status;<br>&#125;<br><br>int exec_or_node(ASTNode *node, int in_subshell) &#123;<br>    int status = execute_ast(node-&gt;binary.left, in_subshell);<br>    if (status != 0) &#123;<br>        return execute_ast(node-&gt;binary.right, in_subshell);<br>    &#125;<br>    return status;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于任意一个节点AST我们都按照统一的流程进行处理，首先由execute_ast判断当前节点类型进行分派。</p><p>如果是sequence_node（分号），先执行左子节点后执行右子节点，实现一行多指令效果，同时左侧指令先于右侧指令执行。</p><p>如果是and_node或者or_node（条件执行），先执行左子节点，同时获取左子节点的返回值，再以此判断是否执行右子节点，如何获取返回值在后续会具体展开回答。</p><p>如果是pipe_node（管道），开两个子进程，并将标准输入输出重定向到管道实现参数传递，由于在子进程执行，所以不影响shell进程的标准输入输出。</p><p>如果是redirection_node（重定向），先打开对应文件，并根据重定向类型选择标准输入或者输出重定向到对应文件描述符，然后执行指令即可。</p><p>如果是command_node（指令），则判断是内建指令还是外部指令，内建指令进入run_builtin,外部指令按lab6流程来，如下图：</p><p><img src="/../images/spawn.png" alt="img.png"></p><p>进入spawn函数处理流程。</p><p>至此我们就完整的重构好了lab6的指令分析和执行部分的内容，这位我们后面的工作带来了很大的便利，事实上，我们在重构的过程中已经实现很多指令优化部分的内容了，这就是语法树的强大所在。</p><p>让我们进入真正的shell拓展内容：</p><h2 id="相对路径支持"><a href="#相对路径支持" class="headerlink" title="相对路径支持"></a>相对路径支持</h2><h3 id="open-remove"><a href="#open-remove" class="headerlink" title="open remove"></a>open remove</h3><p>在原始的mos里只支持绝对路径，所以要想支持相对路径最简单快捷的办法就是更改文件系统里的代码。</p><p>我们只需要在文件open、remove的时候将rq-&gt;path改为绝对路径即可，关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\user/lib/file.c open<br>if (has_relative_component(path)) &#123;<br>strcpy(buf, path);<br>normalize_path_inplace1(curwd, buf);<br>path = buf;<br>//debugf(&quot;normalize path: %s\n&quot;, path);<br>&#125; else if (path[0] != &#x27;/&#x27;)&#123;<br>if (!str_eq1(curwd, &quot;/&quot;)) &#123;<br>strcpy(curwd + strlen(curwd), &quot;/&quot;);<br>&#125;<br>strcpy(curwd + strlen(curwd), path);<br>path = curwd;<br>//debugf(&quot;cat path: %s\n&quot;, path);<br>&#125;<br>\\user/lib/file.c remove<br>    char curwd[1024];<br>syscall_get_cwd(curwd);<br>char buf[1024];<br>strcpy(buf, path);<br>normalize_path_inplace1(curwd, buf);<br>path = buf;<br></code></pre></td></tr></table></figure><p>其中normalize_path_inplace1是将buf依据当前工作路径进行拓展，这样就能支持参数里的相对路径了。</p><h3 id="cd、pwd和当前工作目录"><a href="#cd、pwd和当前工作目录" class="headerlink" title="cd、pwd和当前工作目录"></a>cd、pwd和当前工作目录</h3><p>下一步我们需要实现两个内建指令cd和pwd</p><p>cd指令的实现本次挑战性任务最难的部分，因为cd需要更改当前shell的工作目录，而这部分与进程强相关，在mos中是先fork一个子进程然后再执行run_cmd的，因为这样的操作可以避免一些恶意的操作直接导致shell本身被破坏，比如标准输入输出被修改了等等。</p><p>但是这也给我们实现cd带来一个难题，那就是我们如何保证cd能让shell的进程的工作目录被修改呢？</p><p>经过长时间的思考和讨论，我和室友最终采取了一个算是比较轻便的方法，但是不够优雅，对于这次挑战性任务却足够了。</p><p>首先，我们在进程控制块Env中添加一个char cwd[1024]的工作路径属性，用来标记当前shell的工作目录。</p><p>进程创建时，子进程继承父进程的工作目录，若是第一个被创建的进程，cwd被初始化为根目录<code>/</code>。</p><p>然后实现两个系统调用syscall_get_cwd()和syscall_change_cwd(char* path),其中关键的是syscall_change_cwd的实现，在该函数的内核态部分，我们取出当前进程curenv的父进程，并将其父进程的cwd修改为cd的路径，因为cd一定是在runcmd进程或者其子进程中执行的，并且若是在其子进程中执行则不影响shell的工作目录，这一点和bash的行为一致，所以我们只需要修改父进程的cwd即可，而不需要在意更深层的影响。</p><p>关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\内核态部分<br>void sys_change_cwd(char* s) &#123;<br>struct Env* parent_env;<br>envid2env(curenv-&gt;env_parent_id, &amp;parent_env, 0);<br>strcpy(curenv-&gt;cwd, s);<br>strcpy(parent_env-&gt;cwd, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>在cd之前，我们对于路径的合法性也需要检验，并判断是否是目录，同时也需要支持相对路径（和上面一样）</p><p>然后对于pwd的实现就很简单了，只需要取出当前进程的cwd然后输出即可。</p><h2 id="拓展指令"><a href="#拓展指令" class="headerlink" title="拓展指令"></a>拓展指令</h2><p>这部分我们需要实现 mkdir， rm， touch 和exit。</p><p>对于前三个指令，我主要参考了zyt学长的代码，在此感谢zyt学长！！！(<a href="https://github.com/zhangyitonggg/BUAA-OS-challenge">学长的代码</a>)</p><p>同时为了方便实现条件执行，我做了相应的返回值修改</p><p>以下是关键代码：</p><p>mkdir:</p><p>实现思路分-p和无-p两部分，有-p则忽视父目录不存在的情况，若不存在则创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;lib.h&gt;<br><br>int flag;<br><br>int mkdir(char *path) &#123;<br>    int fd;<br>    int result = 0;<br>    if (flag) &#123;<br>        if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>            close(fd);<br>            return;<br>        &#125;<br>        int i = 0;<br>        char str[1024];<br>        for (int i = 0; path[i] != &#x27;\0&#x27;; ++i) &#123;<br>            if (path[i] == &#x27;/&#x27;) &#123;<br>                str[i] = &#x27;\0&#x27;;<br>                if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>                    close(fd);<br>                &#125; else &#123;<br>                    break;<br>                &#125; <br>            &#125;<br>            str[i] = path[i];<br>        &#125;<br>        for (; path[i] != &#x27;\0&#x27;; ++i) &#123;<br>            if (path[i] == &#x27;/&#x27;) &#123;<br>                str[i] = &#x27;\0&#x27;;<br>                //debugf(&quot;path : %s\n&quot;, str);<br>                fd = open(str, O_RDONLY);<br>                if (fd &gt;= 0) &#123;<br>                    close(fd);<br>                &#125; else &#123;<br>                    fd = open(str, O_MKDIR);<br>                    if (fd &gt;= 0) &#123;<br>                        close(fd);<br>                    &#125; else &#123;<br>                        debugf(&quot;error when mkdir\n&quot;);<br>                        result = 1;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            str[i] = path[i];<br>        &#125;<br>        str[i] = &#x27;\0&#x27;;<br>        fd = open(str, O_MKDIR);<br>        if (fd &gt;= 0) &#123;<br>            close(fd);<br>        &#125; else &#123;<br>            printf(&quot;other error when mkdir %s, error code is %d\n&quot;, path, fd);<br>            result = 1;<br>        &#125;<br>    &#125; else &#123;<br>        if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>            close(fd);<br>            printf(&quot;mkdir: cannot create directory &#x27;%s&#x27;: File exists\n&quot;, path);<br>            result = 1;<br>            return;<br>        &#125;<br>        fd = open(path, O_MKDIR);<br>        if (fd == -10) &#123;<br>            printf(&quot;mkdir: cannot create directory &#x27;%s&#x27;: No such file or directory\n&quot;, path);<br>            result = 1;<br>        &#125; else if (fd &lt; 0) &#123;<br>            printf(&quot;other error when mkdir %s, error code is %d\n&quot;, path, fd);<br>            result = 1;<br>        &#125; else &#123;<br>            close(fd);<br>        &#125;<br>    &#125;<br>    return result;<br>&#125;<br><br>int main(int argc, char **argv) &#123;<br>    char s[5] = &quot;-p&quot;;<br>    int result = 0;<br>    for (int i = 1; i &lt; argc; i++) &#123;<br>        if (strcmp(argv[i], s) == 0) &#123;<br>            argv[i] = 0;<br>            flag = 1;<br>            break;<br>        &#125;<br>    &#125;    <br><br>    if (argc &lt; 2) &#123;<br>        user_panic(&quot;nothing to mkdir\n&quot;);<br>    &#125; else &#123;<br>        for (int i = 1; i &lt; argc; ++i) &#123;<br>            if (argv[i] == 0) &#123;<br>                continue;<br>            &#125;<br>            int r = mkdir(argv[i]);<br>            if (r != 0) &#123;<br>                result = 1;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>rm:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;lib.h&gt;<br><br>int flag_r;<br>int flag_f;<br><br>int rm(char *path) &#123;<br>    int fd;<br>    struct Stat st;<br>    if ((fd = open(path, O_RDONLY)) &lt; 0) &#123;<br>        if (!flag_f) &#123;<br>            printf(&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;, path);<br>        &#125;<br>        return 1;<br>    &#125;<br>    close(fd);<br>    stat(path, &amp;st);<br>    if (st.st_isdir &amp;&amp; !flag_r) &#123;<br>        printf(&quot;rm: cannot remove &#x27;%s&#x27;: Is a directory\n&quot;, path);<br>        return 1;<br>    &#125;<br>    remove(path);<br>    <br>    return 0;<br>&#125;<br><br>int main(int argc, char **argv) &#123;<br>    char s_r[5] = &quot;-r&quot;;<br>    char s_rf[5] = &quot;-rf&quot;;<br>    int result = 0;<br>    for (int i = 1; i &lt; argc; i++) &#123;<br>        if (strcmp(argv[i], s_r) == 0) &#123;<br>            argv[i] = 0;<br>            flag_r = 1;<br>        &#125; else if (strcmp(argv[i], s_rf) == 0) &#123;<br>            argv[i] = 0;<br>            flag_f = 1;<br>            flag_r = 1;<br>        &#125;<br>    &#125;<br><br>    if (argc &lt; 2) &#123;<br>        printf(&quot;nothing to rm\n&quot;);<br>    &#125; else &#123;<br>        for (int i = 1; i &lt; argc; ++i) &#123;<br>            if (argv[i] == 0) &#123;<br>                continue;<br>            &#125;<br>            int r = rm(argv[i]);<br>            if (r != 0) &#123;<br>                result = 1;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>touch:<br>实现思路就是先判断文件和父目录是否存在，若父目录不存在则抛出错误，并返回非0值，若文件不存在则创建一个新的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;lib.h&gt;<br><br>int touch(char *path) &#123;<br>    int fd;<br>    int flag = 0;<br>    if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>        close(fd);<br>        return;<br>    &#125;<br>    fd = open(path, O_CREAT);<br>    if (fd == -10) &#123;<br>        printf(&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;, path);<br>        flag = 1;<br>    &#125; else if (fd &lt; 0) &#123;<br>        printf(&quot;other error when touch %s, error code is %d\n&quot;, path, fd);<br>        flag = 1;<br>    &#125; else &#123;<br>        close(fd);<br>    &#125;<br>    return flag;<br>&#125;<br><br>int main(int argc, char **argv) &#123;<br>    int flag = 0;<br>    if (argc &lt; 2) &#123;<br>        printf(&quot;nothing to touch\n&quot;);<br>    &#125; else &#123;<br>        for (int i = 1; i &lt; argc; ++i) &#123;<br>            int r = touch(argv[i]);<br>            if (r != 0) &#123;<br>                flag = 1;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return flag;<br>&#125;<br></code></pre></td></tr></table></figure><p>exit:</p><p>这个指令则是每次readline后特判是不是exit，若是的话则直接执行<code>exit()</code>即可。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>熟悉了工作目录更改的那一套系统调用流程后，这一部分就好多了，我们继续利用万能的进程控制块和系统调用来实现这这一部分内容。</p><p>首先我们在进程控制块里增添新的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct variable &#123;<br>char key[17];<br>char value[17];<br>int mode; //0为全局， 1为局部<br>int perm; //0为可读可写， 1为只读<br>&#125;;<br><br>// Control block of an environment (process).<br>struct Env &#123;<br>struct Trapframe env_tf; // saved context (registers) before switching<br>LIST_ENTRY(Env) env_link; // intrusive entry in &#x27;env_free_list&#x27;<br>u_int env_id; // unique environment identifier<br>u_int env_asid; // ASID of this env<br>u_int env_parent_id; // env_id of this env&#x27;s parent<br>u_int env_status; // status of this env<br>Pde *env_pgdir; // page directory<br>TAILQ_ENTRY(Env) env_sched_link; // intrusive entry in &#x27;env_sched_list&#x27;<br>u_int env_pri; // schedule priority<br><br>// Lab 4 IPC<br>u_int env_ipc_value;   // the value sent to us<br>u_int env_ipc_from;    // envid of the sender<br>u_int env_ipc_recving; // whether this env is blocked receiving<br>u_int env_ipc_dstva;   // va at which the received page should be mapped<br>u_int env_ipc_perm;    // perm in which the received page should be mapped<br><br>// Lab 4 fault handling<br>u_int env_user_tlb_mod_entry; // userspace TLB Mod handler<br><br>// Lab 6 scheduler counts<br>u_int env_runs; // number of times we&#x27;ve been env_run&#x27;ed<br><br>// lab 6_shell<br>char cwd[1024];<br>struct variable var[32];<br>int var_num;<br>int last_call;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后继续按cd那一套来，增添4个系统调用，分别用来设置环境变量，取消环境变量，查询环境变量以及打印环境变量。</p><p>同理，这四个系统调用也是针对的父进程的环境控制块进行的操作。</p><h2 id="输入优化"><a href="#输入优化" class="headerlink" title="输入优化"></a>输入优化</h2><h3 id="指令自由输入"><a href="#指令自由输入" class="headerlink" title="指令自由输入"></a>指令自由输入</h3><p>这一部分我们修改readline的内容，保证readline能处理左右方向键和Backspace.</p><p>先设置好当前输入长度和光标位置变量。</p><p>识别当前字符是左右键时就移动光标到相应位置，相对对应的，输入字符时就让光标右边的字符整体右移一格，然后在光标处设置为当前字符，然后光标自增1。</p><p>识别当前字符是Backspace时，就让光标右边的字符整体左移一格，然后光标自减。</p><p>关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int len = 0;         // 实际输入长度<br>int cursor = 0;      // 当前光标位置<br>int r;<br>char c;<br><br>    else if (c == 0x7f || c == &#x27;\b&#x27;) &#123;  // Backspace<br>        if (cursor &gt; 0) &#123;<br>            // 1. 删除缓冲区字符<br>            for (int i = cursor - 1; i &lt; len - 1; i++)<br>                buf[i] = buf[i + 1];<br>            len--;<br>            cursor--;<br>            // 2. 打印从当前位置到结尾的字符（覆盖旧内容）<br>            putchar(&#x27;\b&#x27;);               // 移动光标到被删字符位置<br>            for (int i = cursor; i &lt; len; i++)<br>                putchar(buf[i]);<br>            putchar(&#x27; &#x27;);                     // 清除旧的最后一个字符<br>            // 3. 把光标移回原位<br>            for (int i = cursor; i &lt;= len; i++)<br>                putchar(&#x27;\b&#x27;);<br>        &#125;<br>    &#125; else if (c == &#x27;\x1b&#x27;) &#123;  // Escape sequence<br>        char seq[2];<br>        if (read(0, &amp;seq[0], 1) != 1) continue;<br>        if (read(0, &amp;seq[1], 1) != 1) continue;<br>        if (seq[0] == &#x27;[&#x27;) &#123;<br>            if (seq[1] == &#x27;D&#x27;) &#123;  // Left arrow<br>                if (cursor &gt; 0) &#123;<br>                    cursor--;<br>                &#125;<br>            &#125; else if (seq[1] == &#x27;C&#x27;) &#123;  // Right arrow<br>                if (cursor &lt; len) &#123;<br>                    cursor++;<br>                &#125; else &#123;<br>                    <br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h3 id="不带-b-后缀指令"><a href="#不带-b-后缀指令" class="headerlink" title="不带 .b 后缀指令"></a>不带 .b 后缀指令</h3><p>这一点只需要修改spawn就行，当当前文件打不开时就在文件路径后面加.b再打开以此即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int open_again_with_b(char *prog) &#123;<br>char temp[256];<br>int i;<br>for (i = 0; prog[i] != &#x27;\0&#x27;; ++i) &#123;<br>temp[i] = prog[i];<br>&#125;<br>temp[i++] = &#x27;.&#x27;;<br>temp[i++] = &#x27;b&#x27;;<br>temp[i] = &#x27;\0&#x27;;<br>return open(temp, O_RDONLY);<br>&#125;<br><br>if (((fd = open(prog, O_RDONLY)) &lt; 0) &amp;&amp; ((fd = open_again_with_b(prog)) &lt; 0)) &#123;<br>return fd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>同理也只需要修改readline即可</p><p>代码大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">else if (c == CTRL(&#x27;A&#x27;)) &#123;  // Ctrl-A: Move to beginning<br>    while (cursor &gt; 0) &#123;<br>        putchar(&#x27;\b&#x27;);<br>        cursor--;<br>    &#125;<br>&#125; else if (c == CTRL(&#x27;E&#x27;)) &#123;  // Ctrl-E: Move to end<br>    while (cursor &lt; len) &#123;<br>        putchar(&#x27;\033[C&#x27;);<br>        cursor++;<br>    &#125;<br>&#125; else if (c == CTRL(&#x27;K&#x27;)) &#123;  // Ctrl-K: Kill to end<br>    for (int i = cursor; i &lt; len; i++) &#123;<br>        buf[i] = &#x27;\0&#x27;;<br>        putchar(&#x27; &#x27;);<br>    &#125;<br>    for (int i = cursor; i &lt; len; i++) &#123;<br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    len = cursor;<br>&#125; else if (c == CTRL(&#x27;U&#x27;)) &#123;  // Ctrl-U: Kill from start to cursor<br>    for (int i = 0; i &lt; cursor; i++) &#123;<br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    for (int i = 0; i &lt; cursor; i++) &#123;<br>        putchar(&#x27; &#x27;);<br>    &#125;<br>    for (int i = 0; i &lt; cursor; i++) &#123;<br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    for (int i = 0; i + cursor &lt; len; i++) &#123;<br>        buf[i] = buf[i + cursor];<br>    &#125;<br>    len -= cursor;<br>    cursor = 0;<br>&#125; else if (c == CTRL(&#x27;W&#x27;)) &#123;  // Ctrl-W: Delete previous word<br>    int original = cursor;<br>    // 删除空白<br>    while (cursor &gt; 0 &amp;&amp; (buf[cursor - 1] == &#x27; &#x27; || buf[cursor - 1] == &#x27;\t&#x27;)) &#123;<br>        for (int i = cursor - 1; i &lt; len - 1; i++)<br>            buf[i] = buf[i + 1];<br>        len--;<br>        cursor--;<br>        putchar(&#x27;\b&#x27;); <br>        putchar(&#x27; &#x27;); <br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    // 删除非空白<br>    while (cursor &gt; 0 &amp;&amp; buf[cursor - 1] != &#x27; &#x27; &amp;&amp; buf[cursor - 1] != &#x27;\t&#x27;) &#123;<br>        for (int i = cursor - 1; i &lt; len - 1; i++)<br>    buf[i] = buf[i + 1];<br>        len--;<br>        cursor--;<br>        putchar(&#x27;\b&#x27;); <br>        putchar(&#x27; &#x27;); <br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="实现注释功能"><a href="#实现注释功能" class="headerlink" title="实现注释功能"></a>实现注释功能</h3><p>这部分内容比较简单，只需要在runcmd之前遍历一遍指令内容，遇到<code>#</code>就替换为<code>\0</code>即可。</p><h3 id="实现一行多指令"><a href="#实现一行多指令" class="headerlink" title="实现一行多指令"></a>实现一行多指令</h3><p>得益于语法树的强大，这部分内容已经在语法树执行过程中完成了。</p><h2 id="历史指令"><a href="#历史指令" class="headerlink" title="历史指令"></a>历史指令</h2><p>题目要求我们把指令存在根目录的<code>.mos_history</code>里。</p><p>那我们就按照题目要求，在shell创建之初就先打开<code>.mos_history</code>，若不存在就创建一个，若存在则用于初始化内存中的history数组。</p><p>同时设立一个全局变量history数组用于在内存中存储最近的20条history。</p><p>每当从readline读取一行指令时，就更新一次history数组，并将数组内容全部覆盖写进<code>.mos_history</code>。</p><p>同时像识别左右键一样识别上下键，实现指令的切换。</p><p>这样我们就完成了历史指令的实现。</p><p>关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">else if (c == &#x27;\x1b&#x27;) &#123;  // Escape sequence<br>    char seq[2];<br>    if (read(0, &amp;seq[0], 1) != 1) continue;<br>    if (read(0, &amp;seq[1], 1) != 1) continue;<br>    if (seq[0] == &#x27;[&#x27;) &#123;<br>        if (seq[1] == &#x27;D&#x27;) &#123;  // Left arrow<br>            if (cursor &gt; 0) &#123;<br>                cursor--;<br>            &#125;<br>        &#125; else if (seq[1] == &#x27;C&#x27;) &#123;  // Right arrow<br>            if (cursor &lt; len) &#123;<br>                cursor++;<br>            &#125; else &#123;<br>                <br>            &#125;<br>        &#125;  else if (seq[1] == &#x27;A&#x27;) &#123;  // Up arrow: prev history<br>            if (index &gt; 0) &#123;<br>                printf(&quot;\033[E&quot;);  // Move cursor to beginning of next line<br>                if (index == num) &#123;<br>                    buf[len] = &#x27;\0&#x27;;<br>                    strcpy(has_typed_in, buf);<br>                &#125;<br>                index--;<br>                // 清除当前行<br>                while (cursor &gt; 0) &#123; putchar(&#x27;\b&#x27;); cursor--; &#125;<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27; &#x27;);<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27;\b&#x27;);<br>                // 复制历史到 buf<br>                strcpy(buf, history[index]);<br>                buf[strlen(buf) - 1] = &#x27;\0&#x27;;//消去历史中的\n <br>                len = strlen(buf);<br>                cursor = len;<br>                // 打印历史命令<br>                putchar(&#x27;$&#x27;);<br>                putchar(&#x27; &#x27;);<br>                for (int i = 0; i &lt; len; i++) putchar(buf[i]);<br>            &#125;<br>        &#125; else if (seq[1] == &#x27;B&#x27;) &#123;  // Down arrow: next history<br>            if (index &lt; num) &#123;<br>                index++;<br>                // 清除当前行<br>                while (cursor &gt; 0) &#123; putchar(&#x27;\b&#x27;); cursor--; &#125;<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27; &#x27;);<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27;\b&#x27;);<br>                // 如果还在历史中，加载，否则加载has_typed_in;<br>                if (index &lt; num) &#123;<br>                    strcpy(buf, history[index]);<br>                    buf[strlen(buf) - 1] = &#x27;\0&#x27;; //消去历史中的\n <br>                    len = strlen(buf);<br>                &#125; else &#123;<br>                    strcpy(buf, has_typed_in);<br>                    len = strlen(buf);<br>                &#125;<br>                cursor = len;<br>                // 打印当前内容<br>            <br>                for (int i = 0; i &lt; len; i++) putchar(buf[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反引号、追加重定向和条件执行"><a href="#反引号、追加重定向和条件执行" class="headerlink" title="反引号、追加重定向和条件执行"></a>反引号、追加重定向和条件执行</h2><p>这部分是实验cd后第二个比较难的部分</p><h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><p>我们发现，这部分内容也在语法树中得到了解决.</p><p>首先是词法分析，当我们已经偶数次遇到反引号时，我们就将下一次遇见的反引号的Token类型记为<code>T_Backquote_Open</code>,否则记为<code>T_Backquote_Close</code></p><p>然后是语法分析，当我遇见<code>T_Backquote_Open</code>时，进入parse_list的循环调用中，解析一个完整的指令并返回根节点，存储在command节点中。</p><p>然后是执行部分，在重定向和command执行前，均先检查是否存在反引号未解析，如果有，则开管道和子进程，先让反引号里的指令执行并输出到管道中，然后从管道中取出输出填补到command的已经标记好的index处。</p><p>关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\词法：<br>    else if (c == &#x27;`&#x27;) &#123;<br>        char value[2];<br>strcpy(value, &quot;`&quot;);<br>        if (backquote_num%2 == 0) &#123;<br>            t-&gt;type = T_BACKQUOTE_OPEN;<br>        &#125; else &#123;<br>            t-&gt;type = T_BACKQUOTE_CLOSE;<br>        &#125;<br>        backquote_num++;<br>t-&gt;value = alloc_string(value);<br>lexer.pos += 1;<br>        //debugf(&quot;backquote!\n&quot;);<br>    &#125;<br>\\语法 （parse_command（）函数）<br>    while (current_token.type == T_WORD || current_token.type == T_BACKQUOTE_OPEN) &#123;<br>        if (current_token.type == T_WORD) &#123;<br>            argv[argc++] = current_token.value;<br>            next_token();   <br>        &#125; else &#123;<br>            next_token();<br>            backquote_ast = parse_list();<br>            if (!accept_token(T_BACKQUOTE_CLOSE)) &#123;<br>                debugf(&quot;parse back quote wrong!\n&quot;);<br>                exit();<br>            &#125;<br>            backquote_index = argc;<br>            argc++;<br>        &#125;<br>    &#125;<br>    <br>\\ 执行<br>void handleBackquote(ASTNode *node) &#123;<br>    char **argv = node-&gt;command.argv;<br>    if (node-&gt;command.backquote_index &gt;= 0) &#123;<br>        int p[2];<br>        if(pipe(p) &lt; 0) &#123;<br>            debugf(&quot;failed to create pipe\n&quot;);<br>            exit();<br>        &#125;<br>        int backquote = fork();<br>        if (backquote &lt; 0) &#123;<br>            debugf(&quot;failed to fork in sh.c\n&quot;);<br>            exit();<br>        &#125; else if (backquote == 0) &#123; // 子进程执行反引号部分<br>            close(p[0]);<br>            dup(p[1], 1);<br>            close(p[1]);<br>            execute_ast(node-&gt;command.backquote, 0);<br>            exit();<br>        &#125; else &#123; // 父进程处理argv<br>            close(p[1]);<br>            char outbuf[1024];<br>            memset(outbuf, 0, sizeof(outbuf));<br>            int offset = 0;<br>            int read_num = 0;<br>            while((read_num = read(p[0], outbuf + offset, sizeof(outbuf) - offset - 5)) &gt; 0) &#123;<br>                offset += read_num;<br>            &#125;<br>            if (read_num &lt; 0) &#123;<br>                debugf(&quot;error in `\n&quot;);<br>                exit();<br>            &#125;<br>            close(p[0]);<br>            for (int i = strlen(outbuf) - 1; i &gt;= 0; i--) &#123;<br>                if (outbuf[i] == &#x27; &#x27; || outbuf[i] == &#x27;\n&#x27;) &#123;<br>                    outbuf[i] = &#x27;\0&#x27;;<br>                &#125; else &#123;<br>                    break;<br>                &#125;<br>            &#125;<br>            argv[node-&gt;command.backquote_index] = alloc_string(outbuf);<br>        &#125;<br>        node-&gt;command.backquote_index = -1;<br>    &#125;<br>&#125;<br><br>int exec_command_node(ASTNode *node, int in_subshell) &#123;<br>    char **argv = node-&gt;command.argv;<br>    if (argv[0] == NULL) return 0;<br>    //处理反引号<br>    handleBackquote(node);<br><br>int exec_redirection_node(ASTNode *node, int in_subshell) &#123;<br>    int fd;<br>    handleBackquote(node-&gt;redirect.child);<br></code></pre></td></tr></table></figure><h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>这部分内容也很简单，新增文件打开类型O_APPEEND，，同时在serve_open里支持O_APPEND,将文件的偏移设置为文件大小即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (rq-&gt;req_omode &amp; O_APPEND) &#123;<br>    ff-&gt;f_fd.fd_offset = ff-&gt;f_file.f_size;<br>    // debugf(&quot;offset: %d\n&quot;, ff-&gt;f_fd.fd_offset);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h3><p>这部分内容也和语法树紧密关联，可以看出来，在语法树执行阶段，每一层的执行函数都有返回值，其实这就是我为条件执行留下的通道。</p><p>每一层返回子层的返回值，归根结底，最初的返回值就落到了内建指令和外部指令中了。</p><p>内建指令部分处理起来比较简单，返回值可以立马得到。</p><p>但是外部指令是调用了spawn，开了子进程运行的，所以我们需要在子进程结束前通过某种方式让父进程知道子进程的运行状况。</p><p>我们再次利用上万能的进程控制块Env,在控制块里新增属性last_call。</p><p>然后新增两个系统调用syscall_set_lastcall和syscall_get_lastcall。</p><p>外部指令最终都会在libos.c中的libmain里exit，所以我们做如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void libmain(int argc, char **argv) &#123;<br>// set env to point at our env structure in envs[].<br>env = &amp;envs[ENVX(syscall_getenvid())];<br><br>// call user main routine<br>int r = main(argc, argv);<br>// exit gracefully<br>//向父进程发送结果。<br>syscall_set_last_call(r);<br>exit();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在exec_command_node中捕获返回值并返回即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">   if (is_builtin(argv[0])) &#123;<br>       return run_builtin(argv);<br>   &#125; else &#123;<br>       int child = spawn(argv[0], argv);<br>if (child &gt;= 0) &#123;<br>wait(child);<br>&#125; else &#123;<br>debugf(&quot;spawn %s: %d\n&quot;, argv[0], child);<br>&#125;<br>       int r = syscall_get_last_call();<br>       return r;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了这次挑战性任务的所有内容！！！！（完结撒花</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一学期的os就这样刷的一下过去了，从最初的懵懵懂懂到写完自己的shell，感觉自己对操作系统的运作流程有了质的飞跃（系统调用和Env获得了MVP!!</p><p>在通过自己一点一点的努力下，看到自己的shell成功的运行了起来，内心是无比的开心的，shell的挑战性任务不算简单，但是也是很艰难的完成的，花了很长时间去构想怎么在现有的代码架构上达到新的需求呢，到最后也是选择了重构，收获很多。</p><p>至此，经过co和os的拷打，自己也算是体验过了手搓一台具有交互能力的现代计算机了。</p><p>最后，感谢老师和助教一学期的辛苦工作！感谢这学期帮助过我的同学以及学长学姐的播客！感谢有os这门课！</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit4</title>
      <link href="/2025/06/14/ooUnit4/"/>
      <url>/2025/06/14/ooUnit4/</url>
      
        <content type="html"><![CDATA[<h1 id="UML及oo总结"><a href="#UML及oo总结" class="headerlink" title="UML及oo总结"></a>UML及oo总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>仿佛是昨天，我还在de第一单元多项式的bug，回忆起Unit1的痛苦经历，再看到Unit4满分（难度不一样哈哈哈，不过也确实是成长了），感慨万分，可能是因为oo让我这个学期过于充实了吧，所以感觉是如此的快，要和oo告一段落了。</p><h2 id="UML正向建模与开发"><a href="#UML正向建模与开发" class="headerlink" title="UML正向建模与开发"></a>UML正向建模与开发</h2><p>在本单元，我们实践了先进行UML图的建模再根据UML图来构建自己的代码的过程，三次作业分别让我们画了UML类图、状态图和时序图。</p><p>UML正向建模给我的第一印象是比直接写code要复杂的，究其原因肯定在于我们的项目比较简单，当项目的初始规模非常复杂后，UML的作用就能体现出来了，这个单元前两次作业我耐着性子先画出了UML图再进行代码的编写的，以体会UML的价值所在。提前设计好类并构想好关键类的协作与状态转变，其实相当于把以前写代码时边写边想的过程分离了，这个思想感觉也有些面向对象的感觉哈哈哈。<br>我们在设计的时候只需要保证设计的合理与正确即可，写code的时候也只需要保证代码符合设计并且不出错即可。这样设计与实现分离的想法为复杂工程带来了可能性。写代码时可能会遇见初始设计不合理的地方，这时就要停止code的工作去更改设计，然后再继续进行code的编写。</p><p>UML图在测试时也给我们提供了方向，我们还可以测试code与UML模型之间的统一性。</p><h2 id="架构设计与统一性"><a href="#架构设计与统一性" class="headerlink" title="架构设计与统一性"></a>架构设计与统一性</h2><p>下面是我这单元的UML类图和UML状态图以及对应的代码（时序图画的过于简单就不展示了）</p><p>首先是UML类图：<br><img src="/../images/UML%E7%B1%BB%E5%9B%BE.png" alt="img.png"><br>对应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Library &#123;<br>    private BookShelf bookShelf = new BookShelf();<br>    private BookShelf hotBookShelf = new BookShelf();<br>    private HashSet&lt;LibraryBookIsbn&gt; toBeHot = new HashSet&lt;&gt;();<br>    private HashSet&lt;Book&gt; bro = new HashSet&lt;&gt;();<br>    private HashMap&lt;String, ReserveOrder&gt; ao = new HashMap&lt;&gt;(); //stuId-order<br>    private ArrayDeque&lt;ReserveOrder&gt; orderDeque = new ArrayDeque&lt;&gt;();<br>    private HashSet&lt;String&gt; hadOrderdIds = new HashSet&lt;&gt;();<br>    private HashMap&lt;String, Book&gt; rr = new HashMap&lt;&gt;(); //stuId-Book<br>    private HashMap&lt;LibraryBookId, Book&gt; books = new HashMap&lt;&gt;();<br>    private HashMap&lt;String, User&gt; users = new HashMap&lt;&gt;(); //stuId-User<br>    private HashMap&lt;LibraryBookId, Pair&lt;LocalDate, String&gt;&gt; borrowedBooks = new HashMap&lt;&gt;();<br>    private LocalDate lastOpen = null;<br>    operations...<br>&#125;<br>public class Book &#123;<br>    private LibraryBookId id;<br>    private LibraryBookState state = LibraryBookState.BOOKSHELF;<br>    private ArrayDeque&lt;LibraryTrace&gt; deque = new ArrayDeque&lt;&gt;();<br>    private int due;<br>    operations...<br>&#125;<br>public class BookShelf &#123;<br>    private HashMap&lt;LibraryBookIsbn, HashMap&lt;LibraryBookId, Book&gt;&gt; bookShelf = new HashMap&lt;&gt;();<br>    operations...<br>&#125;<br>public class User &#123;<br>    private String stuId;<br>    private Book bbook;<br>    private HashMap&lt;LibraryBookIsbn, Book&gt; cbooks;<br>    private int credit;<br>    operations...<br>&#125;<br>public class ReserveOrder &#123;<br>    private String usrId;<br>    private LibraryBookIsbn isbn;<br>    private Book book;<br>    private LocalDate date;<br>    operations...<br>&#125;<br></code></pre></td></tr></table></figure><p>我对这次作业的图书馆系统设计了几个关键的类，首先是Book、Library、User，这三个类是最容易抽象出来的，所承担的任务也是最重的，Library负责接受各种命令，User和Book负责和Library交互。<br>同时为了方便管理Book，我还设计了一个BookShelf类，对外提供简介的拿取和放置接口。<br>为了简洁的实现预约功能，我还抽象了一个Order类负责记录各种预约的信息，方便查询和过期处理。</p><p>然后是UML状态图：<br><img src="/../images/UML%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="img.png"></p><p>和对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Trigger(from = &quot;InitState&quot;, to = &quot;BookShelf&quot;)<br>@Trigger(from = &quot;BookShelf&quot;, to = &#123;&quot;User&quot;, &quot;HotBookShelf&quot;, &quot;AppointmentOffice&quot;, &quot;ReadRoom&quot;&#125;)<br>@Trigger(from = &quot;User&quot;, to = &quot;BorrowReturnOffice&quot;)<br>@Trigger(from = &quot;HotBookShelf&quot;, to = &#123;&quot;User&quot;, &quot;BookShelf&quot;, &quot;AppointmentOffice&quot;, &quot;ReadRoom&quot;&#125;)<br>@Trigger(from = &quot;Appointment Office&quot;, to = &quot;BookShelf&quot;)<br>@Trigger(from = &quot;BorrowReturnOffice&quot;, to = &quot;BookShelf&quot;)<br>@Trigger(from = &quot;ReadRoom&quot;, to = &quot;BorrowReturnOffice&quot;)<br>public void move(LocalDate date, LibraryBookState nextState) &#123;<br>    LibraryTrace trace = new LibraryTrace(date, state, nextState);<br>    deque.addLast(trace);<br>    state = nextState;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的Book的状态转移很简单，就是一个move，参数有下一个状态，Book内部记录当前状态，改变当前状态时会记录下这次转移，方便下次查询。</p><p>Book的状态其实就是Book处于什么位置，Book可能出现的位置有：BookShelf、User、AO、BRO、RR、HotBookShelf，一一注意即可。</p><p>UML时序图我画的非常简单，就不展示了。</p><h2 id="大模型辅助正向建模体验"><a href="#大模型辅助正向建模体验" class="headerlink" title="大模型辅助正向建模体验"></a>大模型辅助正向建模体验</h2><p>本次作业助教创新性的引导我们使用大模型来帮我们辅助正向建模。</p><p>用好大模型不是把指导书全丢给他就行了，因为大模型对于业务的理解能力非常差，而要用好大模型，我们就做到对指导书的理解，然后让大模型发挥它的长处（补全）</p><p>大模型补全能力是非常强的，我们只需要加以提示和引导就能构建一个不错的模型。在对于指导书的理解的基础上，给出自己模型的框架，比如需要有什么类，类里有什么基础的属性和方法，承担了什么功能，把这些描述好后让大模型去“补全”就能得到初版，这已经为我们节省了很多的工作，同时我们的思路也能得到新的启发。</p><h2 id="四个单元中架构设计思维的演进与四个单元中测试思维的演进"><a href="#四个单元中架构设计思维的演进与四个单元中测试思维的演进" class="headerlink" title="四个单元中架构设计思维的演进与四个单元中测试思维的演进"></a>四个单元中架构设计思维的演进与四个单元中测试思维的演进</h2><h3 id="设计思维"><a href="#设计思维" class="headerlink" title="设计思维"></a>设计思维</h3><p>首先讲讲设计思维的变化<br>由于oopre的作用，我在接触第一单元时没有那么的吃力，但是现在回顾起当时的设计，还是觉得非常丑陋的，也因此吃了设计不好的亏，第一单元错了很多。<br>一开始只知道要设计类，但是并没有太注意类之间的协作，同时为了实现简介干净，还需要理解封装的重要性。到了第四单元，这些已经改善了许多。<br>然后是一开始是想一出是一出，在屎山上不断的打补丁，这也是非常不好的，首先要做好初步的设计，然后每次迭代都要在原有的设计上重新设计再去code。</p><h3 id="测试思维"><a href="#测试思维" class="headerlink" title="测试思维"></a>测试思维</h3><p>java有两种测试方法<br>一种是面向评测机的测试（bushi，另外一种是写单元测试那一套。<br>第一单元我还不知道测试的重要性，过了中测就没管了，果然强测惨不忍睹。<br>后来我学会了搭建评测机，但是自己编写的实在太简单了，又引入了大模型的帮助，来帮我完善评测机的功能。<br>在JML一章，我还领略了单元测试的强大，在设计上针对每一处做好测试，基本能保证最后的功能正确。</p><h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><p>在oo这门课上我最大的收获是抗压能力变强了，学期初在oo上栽了一个大跟头，但也慢慢的调整了过来，没有脱离大部队的脚步。</p><p>然后是我通过oo这门课学会了工业中存在“设计”这门“艺术”，像荣老师所说，至少知其然也浅浅的知其所以然，算是踏上了成为一名合格的程序员的第一步。</p><p>在此感谢oo这一学期的陪伴，感谢老师与助教的工作！也希望自己能成为oo助教，为课程组带了新的东西！</p>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit3</title>
      <link href="/2025/05/18/ooUnit3/"/>
      <url>/2025/05/18/ooUnit3/</url>
      
        <content type="html"><![CDATA[<h1 id="JML规格化设计"><a href="#JML规格化设计" class="headerlink" title="JML规格化设计"></a>JML规格化设计</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元作业是一个助教辛苦，学生幸福的单元，首先感谢助教对于JML的接口规格化设计。</p><h2 id="第三单元测试过程"><a href="#第三单元测试过程" class="headerlink" title="第三单元测试过程"></a>第三单元测试过程</h2><h3 id="对测试的理解"><a href="#对测试的理解" class="headerlink" title="对测试的理解"></a>对测试的理解</h3><ol><li>单元测试，目标：验证最小功能单元（函数、类）是否按预期运行。</li><li>功能测试，目标：验证功能是否符合需求规格。</li><li>集成测试，目标：验证多个模块组合后的协同工作是否正常。</li><li>压力测试，目标：测试系统在高负载、大数据量下是否稳定、性能合理。</li><li>回归测试，目标：确保旧功能在新版本中仍然正确。</li></ol><h3 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h3><ol><li><p>状态跟踪使用 existing_person_ids、existing_relations 等集合保存已创建实体，确保生成的命令多数为有效命令；避免了生成无效命令浪费测试机会。</p></li><li><p>概率控制 每次生成 ID 时有 80% 以上概率使用已存在的 ID，20% 左右概率生成不存在的 ID，用于测试非法输入处理； 保证测试“有效性 + 鲁棒性”兼备。</p></li><li><p>模块覆盖与比例平衡明确控制三大模块（HW1、HW2、HW3）的命令分布权重；比如HW3权重更高（如 am、aem），适应后期重点测试。</p></li><li><p>边界情况生成比如 ID 范围为 [-100, 100]，年龄范围为 [1, 200]； 使用不同数据长度（如随机生成长度 1~100 的名字）。</p></li><li><p>指令生成路径，按照一定的策略随机的生成指定数量的指令，负责测试程序的不同功能。</p></li></ol><h2 id="大模型辅助"><a href="#大模型辅助" class="headerlink" title="大模型辅助"></a>大模型辅助</h2><h3 id="一、整体策略：从“提问者”到“指挥者”"><a href="#一、整体策略：从“提问者”到“指挥者”" class="headerlink" title="一、整体策略：从“提问者”到“指挥者”"></a>一、整体策略：从“提问者”到“指挥者”</h3><p>大模型的强项是语言理解与上下文记忆，而不是通灵。要发挥其最大效能，关键在于你如何设计任务结构、输入信息与交互节奏。可遵循以下三步法：</p><ul><li><p>目标清晰（What）明确告诉模型你要做什么，如：“我正在开发一个评测机，请帮我生成合理的测试用例生成器。”</p></li><li><p>约束充分（How）提供必要背景与规则：输入格式、限制条件、边界值、接口定义、已有类说明等。</p></li><li><p>拆解合理（Step by step）将复杂任务拆解为子任务，让模型逐步完成（如先写接口草图，再实现核心函数，最后补充状态维护）。</p></li></ul><h3 id="二、不同典型场景下的引导技巧"><a href="#二、不同典型场景下的引导技巧" class="headerlink" title="二、不同典型场景下的引导技巧"></a>二、不同典型场景下的引导技巧</h3><h4 id="场景一：规格化设计（接口与架构）"><a href="#场景一：规格化设计（接口与架构）" class="headerlink" title="场景一：规格化设计（接口与架构）"></a>场景一：规格化设计（接口与架构）</h4><p>目标：设计合理的类、方法、数据结构</p><p>引导技巧：</p><p>明确提出功能要求（如“实现一个支持动态添加好友、标签的社交网络类”）</p><p>说明输入输出格式（如命令格式 ap id name age）</p><p>提供已有组件（如你已有的 Person 类定义）</p><p>可用 prompt 模板示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">我希望你帮我设计一个 Java 类 `Network`，它支持以下命令：<br>- `ap id name age`：添加用户<br>- `ar id1 id2 val`：建立关系<br>  这个类应该如何设计接口？需要哪些内部数据结构？<br></code></pre></td></tr></table></figure><h4 id="场景二：代码实现（核心算法、状态维护）"><a href="#场景二：代码实现（核心算法、状态维护）" class="headerlink" title="场景二：代码实现（核心算法、状态维护）"></a>场景二：代码实现（核心算法、状态维护）</h4><p>目标：写出能工作的函数&#x2F;类</p><p>引导技巧：</p><p>提供函数签名与预期行为（如“输入为命令列表，输出为处理结果”）</p><p>提供已有代码片段、类定义供调用</p><p>可示例性描述一些关键输入输出</p><p>若模型写的第一版不够精确，可反复对细节提问并要求“逐行解释你的代码”</p><h4 id="场景三：测试与验证"><a href="#场景三：测试与验证" class="headerlink" title="场景三：测试与验证"></a>场景三：测试与验证</h4><p>目标：构造测试用例，验证正确性</p><p>引导技巧：</p><p>给出你期望测试的函数或命令格式（如 “qv id1 id2”）</p><p>明确边界（如“我要测试最大长度字符串输入”）</p><p>命令示例 + 状态约束（如“已存在的 ID 集合是 {1, 2, 3}，请生成合法但边界的 mr 命令”）</p><h4 id="场景四：优化与分析"><a href="#场景四：优化与分析" class="headerlink" title="场景四：优化与分析"></a>场景四：优化与分析</h4><p>目标：让模型分析瓶颈、重构代码或提出设计优化建议</p><p>引导技巧：</p><p>提供当前实现代码 + 描述性能瓶颈</p><p>提出明确优化目标（如“将当前 getValueSum() 从 O(n) 降为 O(1)”）</p><p>要求模型分析时提供理由，不仅是结论</p><h2 id="关键数据结构和算法设计"><a href="#关键数据结构和算法设计" class="headerlink" title="关键数据结构和算法设计"></a>关键数据结构和算法设计</h2><h3 id="hw9"><a href="#hw9" class="headerlink" title="hw9"></a>hw9</h3><p>Person:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Person implements PersonInterface &#123;<br>    private String name;<br>    private int age;<br>    private int id;<br>    private HashMap&lt;Integer, PersonInterface&gt; acquaintance;<br>    private HashMap&lt;Integer, PersonValuePair&gt; values;<br>    private HashMap&lt;Integer, TagInterface&gt; tags;<br>    private TreeSet&lt;PersonValuePair&gt; ts = new TreeSet&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便查询acquaintance，使用了复杂度为O(1)的HashMap来存储Person的好友。</p><p>本次作业中，Person需要注重考虑优化getBestAcquaintance()方法，于是我采用了java自己的treeSet来实现O(logn)维护，O(1)查询，只需要重写Set中元素的compareTo()方法即可线上维护value的顺序。</p><p>Tag:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Tag implements TagInterface &#123;<br>    private int id;<br>    private HashMap&lt;Integer, PersonInterface&gt; persons;<br>    private int sum = 0;<br>    private int sum2 = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>本次作业Tag需要注意的点是getAgeMean()和getAgeVar()，本人同样实现了O(1)维护，O(1)查询的方法，只需要维护好value和以及value^2和即可。</p><p>NetWork:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Network implements NetworkInterface &#123;<br>    private HashMap&lt;Integer, PersonInterface&gt; persons;<br>    private int triple = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>NetWork的难点主要体现在查询三元环数量以及连通性查询</p><p>关于三元环的查询，我选择维护一个triple变量，在每一次加边和删边操作时进行O(N)的维护，实测效果很好。</p><p>关于连通性查询，我见许多同学使用了并查集这个数据结构，但是本次作业中涉及到了删边操作，但是并查集并不支持删边后的查询，于是只能重建，鉴于实现起来过于复杂，我选择了BFS查询连通性，这一算法在后续接口中也会使用，只能说性价比极高。</p><h3 id="hw10"><a href="#hw10" class="headerlink" title="hw10"></a>hw10</h3><p>新增类OfficialAccount：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class OfficialAccount implements OfficialAccountInterface &#123;<br>    private int ownerId;<br>    private int id;<br>    private String name;<br>    private HashMap&lt;Integer, PersonInterface&gt; followers;<br>    private HashMap&lt;Integer, PersonInterface&gt; articles;<br>    private HashMap&lt;Integer, PersonValuePair&gt; contributions;<br>    private TreeSet&lt;PersonValuePair&gt; ts;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是本次作业新增的类OfficialAccount，主要负责维护公众号的关注者和文章（仅关注ID）以及相应关注者的贡献。</p><p>需要注意的地方只有一个接口getBestContributor()，所以我们选择和上次作业一样的做法，用TreeSet来维护贡献的有序性，然后就可以很快的查询最佳贡献者了。</p><p>Person改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Person implements PersonInterface &#123;<br>    private TreeMap&lt;Integer, Integer&gt; receivedArticles;<br>    private HashMap&lt;Integer, Integer&gt; articles;<br>    private HashMap&lt;PersonValuePair, TagInterface&gt; otherTags;<br>    private int order = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要维护Person收到的文章以及他们接受的顺序，由于在这一次作业中不可能出现一个人多次接受同一篇文章，所以我们用Map来存储article。</p><p>但是问题来了，我们怎么维护文章的接受顺序呢？没错，又是TreeMap，我们在Person里维护一个取号机制，来一篇文章取一个号，同时号码减一，然后利用TreeMap能维护Key的顺序的机制，我们就能维护好文章的顺序啦，先进来的文章取得号一定大于后进来的文章。</p><p>我们还注意到我维护了一个otherTags，这其实是为了Network里的一个接口服务的，这里暂不讲解。</p><p>Tag改动：</p><p>Tag新增了一个对于内部Person之间value和的查询，但是这个实现主要是在Network中维护的，所以不在这里讲解了。</p><p>Network改动：</p><p>新增了双元环数量的查询（当一对Perosn互为最好的朋友时就视为一个双元环），这个维护方法和三元环类似，主要是在网络中加边删边时正确更改即可。</p><p>新增了对于TagValueSum的查询，注意到我在Person里维护了Person被归类的Tag，这样就可以在更改关系时查询会涉及到哪些Tag的valueSum，然后一一线上维护即可。</p><p>新增了最短路径的接口，我们采用了BFS的实现，简单高效。</p><h3 id="hw11"><a href="#hw11" class="headerlink" title="hw11"></a>hw11</h3><p>本次作业的改动主要为新增了Message类，Message承担了转发文章（被转发的人会接受），发红包（更改Person的Money值），发表情包的作用，同时会增加转发于被转发者的社交值。</p><p>在时间复杂度上没有什么难点，只需要注意处理机制就行，因为这次作业的JML超长！！！！</p><h2 id="从规格到实现，性能如何保障？"><a href="#从规格到实现，性能如何保障？" class="headerlink" title="从规格到实现，性能如何保障？"></a>从规格到实现，性能如何保障？</h2><p>JML设计者在写规格时想的一定不是具体的实现方法，而是怎么去简单又完美的约束好一个接口的功能与副作用，是站在整体的角度思考问题的，想好了一切可能的行为，分别做好不同的约束处理。</p><p>实现则是在遵守JML约束的前提下，尽可能的提高实现的性能。此时工作人员想的是一个具体的实现方法。</p><h2 id="JUNIT测试"><a href="#JUNIT测试" class="headerlink" title="JUNIT测试"></a>JUNIT测试</h2><h3 id="一、JUnit-测试的本质与作用"><a href="#一、JUnit-测试的本质与作用" class="headerlink" title="一、JUnit 测试的本质与作用"></a>一、JUnit 测试的本质与作用</h3><p>JUnit 是 Java 中最常用的单元测试框架，主要用于：</p><ul><li><p>自动化验证类和方法的行为是否符合预期规格；</p></li><li><p>支持回归测试，及时发现代码修改带来的错误；</p></li><li><p>增强测试覆盖率（代码分支、边界、异常情况）；</p></li><li><p>与规格（如 JML）结合时，充当规格实现一致性的验证器。</p></li></ul><h3 id="二、利用“规格信息”设计-JUnit-测试的思路"><a href="#二、利用“规格信息”设计-JUnit-测试的思路" class="headerlink" title="二、利用“规格信息”设计 JUnit 测试的思路"></a>二、利用“规格信息”设计 JUnit 测试的思路</h3><ol><li>明确每个方法的规格（前置条件、后置条件、不变量）设计测试用例时：依据每条规格构造一个正例 + 至少一个反例。</li><li>将规格翻译为断言（assert）JUnit 提供 assertEquals, assertTrue, assertThrows 等断言方法。</li><li>结合边界值与等价类分析基于规格设计测试数据，覆盖各类输入场景。</li></ol><h3 id="三、JUnit-测试验证规格一致性的效果体现"><a href="#三、JUnit-测试验证规格一致性的效果体现" class="headerlink" title="三、JUnit 测试验证规格一致性的效果体现"></a>三、JUnit 测试验证规格一致性的效果体现</h3><ol><li>捕捉与规格不一致的实现错误如：</li></ol><ul><li><p>规格要求“相同关系不可重复添加”，但实现却允许重复；</p></li><li><p>JML 声明“添加后 size 增加”，但实际调用无变化。</p></li></ul><p>通过 JUnit 断言对比前后状态，可快速识别这些逻辑偏差。</p><ol start="2"><li><p>提高可维护性与回归保障一旦方法规格变更，只需更新对应测试：避免因手动测试遗漏导致旧功能失效；结合 CI&#x2F;CD，可以自动在提交时运行测试，保障规格长期一致性。</p></li><li><p>支持规格驱动开发（Test-first &#x2F; TDD）JUnit 测试与规格结合，可倒逼实现更加规范：先写规格 → 写测试用例 → 最后写实现，类似于“契约驱动开发”，提升代码清晰度与可预测性。</p></li></ol><h3 id="四、实际项目中的-JUnit-设计示例"><a href="#四、实际项目中的-JUnit-设计示例" class="headerlink" title="四、实际项目中的 JUnit 设计示例"></a>四、实际项目中的 JUnit 设计示例</h3><p>假设你有如下 JML 规格定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*@ requires id &gt; 0;<br>@ ensures \result != null;<br>@ ensures \result.getId() == id;<br>@*/<br>public Person getPerson(int id);<br></code></pre></td></tr></table></figure><p>可设计如下 JUnit 测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Test<br>public void testGetPersonNormal() &#123;<br>network.addPerson(1, &quot;Alice&quot;, 20);<br>Person p = network.getPerson(1);<br>assertNotNull(p);<br>assertEquals(1, p.getId());<br>&#125;<br><br>@Test<br>public void testGetPersonInvalidId() &#123;<br>assertThrows(IllegalArgumentException.class, () -&gt; network.getPerson(-1));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>本单元的学习让我真正体会到“规格先行”的重要性。JML 规格不仅仅是对接口行为的约束，更是一种程序设计的思维方式。它迫使我在写代码前先理清楚每一个函数的职责、边界与副作用，从而避免“边写边试、边改边错”的低效流程。</p><p>在实现过程中，面对复杂接口和状态维护时，我深刻认识到：良好的设计是性能和正确性的保障。比如在 Person 类中使用 TreeSet 优化最优好友查询、在 Tag 中用数学方法实现均值与方差的 O(1) 维护、以及在 Network 中用 BFS 替代复杂的连通性维护方案——这些都是在规格指引下不断优化的结果。</p><p>此外，借助大模型的协作能力，我从“提问者”成长为“任务设计者”。我学会了如何清晰地表达意图、分步拆解任务、构建提示模板，并通过反复调试与细节提问来获得更贴合需求的输出。这种交互方式不仅提升了效率，也让我意识到人工智能更像是一个“逻辑助理”，它不会替代你的判断，而是在你的设计之下发挥最大价值。</p><p>最后，JML + JUnit 的组合是一次理论与实践的双重磨砺。它让我意识到代码的正确性从来不是“写完跑一下就行”，而是一种自我约束、一种契约精神。测试不是验收，而是开发的一部分，它推动我不断思考：我的代码，是否真正做到了“言出法随”？</p><p>这个单元虽然挑战很多，但正因为如此，我收获的也更多。感谢助教提供的精细规格，感谢这次设计-实现-测试一体化的宝贵锻炼机会。</p>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit2</title>
      <link href="/2025/04/14/ooUnit2/"/>
      <url>/2025/04/14/ooUnit2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于面向对象多线程电梯那些事"><a href="#关于面向对象多线程电梯那些事" class="headerlink" title="关于面向对象多线程电梯那些事"></a>关于面向对象多线程电梯那些事</h1><p>写在前面：经历面向对象第二单元作业的这三周后，我对于多线程电梯的评价是很好的。这次作业给了我们机会去尝试多线程编程，能实际面临并解决多线程的资源竞争和线程安全问题。对我个人来说，我体会了多线程的复杂与神奇所在，在写每一个独立线程时需要时刻保持警惕，要把其它线程想象为一个陌生的程序员，保护自己的工作逻辑不受其它线程的破坏。</p><h2 id="Unit2三次作业感受"><a href="#Unit2三次作业感受" class="headerlink" title="Unit2三次作业感受"></a>Unit2三次作业感受</h2><p>个人感觉其实第一次作业是最难的，是因为第一次面临多线程设计是最不熟悉的，好在practice3给了我很大的启发和帮助。而第二次和第三次作业则相对简单了很多（不写影子电梯的话）。<br><img src="/../images/%E6%B5%81%E7%A8%8B.png" alt="流程"></p><h3 id="多线程协作与锁的选择"><a href="#多线程协作与锁的选择" class="headerlink" title="多线程协作与锁的选择"></a>多线程协作与锁的选择</h3><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p><img src="/../images/hw5.png" alt="hw5"><br>第一次作业需要设计三种线程，分别是InputHandler（输入处理），Dispatcher（请求分派）和elevator（电梯）；两类共享资源RequestTable（请求总表）和WaitTable（电梯等待队列）。这三种线程两种共享资源构成了两对生产者消费者模型。</p><p>InputHandler线程的逻辑非常简单，就是利用官方包从stdin读入数据并解析请求类型，第一次作业只有PersonRequest，所以InputHandler就只需考虑将请求信息封装为一个对象Person（方便后续电梯中途下人并重新分配电梯），然后作为生产者将Person投喂给RequestTable即可。</p><p>RequestTable作为共享资源，所要面临的是InputHandler的写入和Dispatcher的读出。对于InputHandler提供offer()方法，对Dispatcher提供poll()方法，同时设置一系列RequestTable的状态查询方法（如是否结束或者是否为空，以便所有请求都处理后线程都能正常结束）。荣老师在课上说对对象的方法上synchronized修饰上锁是不合适的，究其原因在于要最小化一个原子操作（待会解释什么是一个原子操作）。但是考虑到RequestTable方法本身非常简单，给方法修饰synchronized反而可能更安全。<br>对于共享资源的保护，我们提及了synchronized修饰符和原子操作这个概念，所谓原子操作，通俗一点的解释就是某一个线程的操作是不可被其它线程插入并修改共享资源从而改变运行逻辑的操作就是一个原子操作，就像原子是物质的基本组成粒子，不可再分（化学层面 :））。理解了原子性这个概念后，我们对于线程安全问题就能更上一层楼了。</p><p>Dispatcher设计或许在这一次作业里没那么重要，但是其存在为后续的非指派的分派算法设计提供了空间。当RequestTable非空时，Dispatcher从总表poll()一个请求，并按照设定的算法分派给对应电梯的WaitTable即可。为避免轮询白白占用cpu资源，我们需要让Dispatcher在RequestTable在为空但是未结束时“睡一会”，这里的“睡一会”并非真的睡觉（sleep），而是调用RequestTable.wait()进入RequestTable的等待队列。<br>这里又会涉及到一个新的概念：wait-notify。Dispatcher会先判断RequestTable的状态并决定是否进入RequestTable的等待队列，这里有两个点需要注意：</p><ol><li>Dispatcher需要分别查询RequestTable是否为空和是否结束，虽说是两次查询，但我们需要将这次行为作为一次原子操作，不然在第一次和第二次查询之间很有可能有其它线程抢走RequestTable的锁并改变了RequestTable的状态导致Dispatcher的逻辑错误。</li><li>为了避免死锁，我们需要在每一次改变共享对象的状态后调用notifyAll()将所有的处于共享对象的等待队列的线程唤醒，但是这个唤醒是无条件的，所以可能存在“假醒”的存在。所以我们需要将wait块包装在while(true)块内，唤醒后再一次查询资源状态，只有满足条件才会真的被唤醒。</li></ol><p>WaitTable同样作为共享资源，其所设计的逻辑和RequestTable是大差不差的，要为Dispatcher提供offer()方法，要为电梯提供poll()方法，内部维护的是分派给对应电梯的Person。</p><p>Elevator作为另一个消费者，其逻辑是根据WaitTable的状态和自身的决策算法，不断选择一定的运动，如移动，载人，放人，等待和结束。</p><p>第一次作业到此就结束了，虽然理清逻辑后觉得很简单，但是多线程编程设计时每写一句可能就需要考虑会不会造成线程冲突和不安全问题，会不会造成死锁问题。</p><h4 id="第二次作业与第三次作业"><a href="#第二次作业与第三次作业" class="headerlink" title="第二次作业与第三次作业"></a>第二次作业与第三次作业</h4><p><img src="/../images/hw6.png" alt="hw6"><br>第二次作业主要的改动有：</p><ol><li>不再提前指定请求分派的电梯，需要Dispatcher通过设计dispatch算法为请求分派请求。</li><li>新增SCHE特殊调度，并且这个调度的优先级很高，需要让电梯尽快的响应。</li></ol><p>这一次作业我觉得有几点设计是值得说一说的：</p><ol><li>将电梯属性和动作全部转至WaitTable维护，电梯本身抽象为一个纯粹的线程，只是不断的调用WaitTable的状态转移函数；电梯属性和电梯动作抽象为WaitTable的数据和属性改变和查询的方法。这么做虽然会大大增加WaitTable的复杂度，但是为外部设计带来了很多便利：<ul><li>Dispatcher设计dispatch算法时避免不了需要同时掌握等待队列和电梯的信息，然后决定分派给谁，当把电梯的属性转至WaitTable统一维护时，Dispatcher就只需要和WaitTable进行交互，同时也能提高电梯数性的安全性，避免了对于电梯属性的数据冲突。</li></ul></li><li>“围师必阙”：这一点设计我其实参考的是讨论区里助教的设计，注意到当电梯进入特殊调度状态时，就不能receive请求了，那如果某段时间只有一个电梯可用，同时这段时间来了大量的请求，如果分派算法设计的不好的话很有可能会把所有的请求都分派给“劳模电梯”，导致运行时间大大增加。那我们怎么解决这个问题呢，我们可以采用缓冲机制（Buffer），讨论区的助教可能是为了设计影子电梯分派算法而设计的这个机制，但是我发现其适用性非常广，于是便吸收进来化为己用。所谓缓冲机制，就是在WaitTable里设置另外一个容器，当Dispatcher决定将某一个请求分派给某一个电梯时，而此时电梯处于特殊调度状态，我们不直接把这个请求“分”给这个电梯，而是把这个请求放进这个特殊的容器，当电梯结束特殊调度状态时自动的把这个容器全部正式接收。</li><li>引入单例模式和多例模式。注意到在设计的过程中，经常需要访问其它对象，在这次作业里频次格外的高，但是把对象作为一个方法的参数传入的话实在不美观，于是我引入了单例模式和工厂模式。注意到RequestTable有且只有一个，电梯和与其对应的WaitTable存在6个。所以我把RequestTable设计为单例模式，把电梯和WaitTable设计为多例模式。其在程序创立之初就已经被静态的创建和存储在对应的Factory里，所以在需要访问某一个对象时就只需要向对应的静态Factory里请求即可。</li></ol><p>这里作业还有一个关于原子操作方面的点值得注意，与第一次作业不同的是，RequestTable还有可能会接受来自电梯的在分派请求，所以RequestTable是否结束的标准改为是否所有的请求都已经完成了，所以电梯在获得等待建议和执行wait进入WaitTable的等待队列的过程中需要保持为一个原子操作，否则，当最后一个电梯完成最后一个请求时，倘若Dispatcher线程插入，为WaitTable设为结束，但是当电梯重新拿回WaitTable的锁时，仍然会调用wait而不是结束线程，这时这个线程就会自此长睡不起了。</p><p><img src="/../images/hw7.png" alt="hw7"><br>第三次作业主要的改动有：</p><ol><li>新增双轿厢电梯，对应UPDATE请求。</li></ol><p>这次作业有两类设计是值得一说的：</p><ol><li>首先是线程同步机制，需要在UPDATE-begin和UPDATE-end进行两次同步，我采用了多例模式和CyclicBarrier结合的形式。我为每一对电梯都创建了实例化了一个CyclicBarrier，并存储在BarrierFactory里，在update的过程中，两个电梯通过同一个CyclicBarrier来进行同步。</li><li>关于双轿厢的设计，我自认为我的设计是比较简洁的。首先是结束UPDATE-end后，我不改变线程数量，仍然认为电梯处于自己的电梯井中，只是限制了其最高楼层和最低楼层，然后对于共享楼层的访问，设立了一个新的类SharedFloor，当电梯需要进入该楼层时，会向SharedFloor申请；当离开楼层时会“释放”该共享楼层的所有。同时要静止电梯在共享楼层等待从而长久的占用共享楼层。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class SharedFloor &#123;<br>    private boolean isOccupied = false;  // 标记是否被占用<br><br>    public synchronized void acquire() throws InterruptedException &#123;<br>        while (isOccupied) &#123;<br>            // 如果已被占用，线程进入等待状态<br>            wait();<br>        &#125;<br>        isOccupied = true;<br>    &#125;<br><br>    public synchronized void release() &#123;<br>        isOccupied = false;<br>        notifyAll(); // 唤醒所有等待的线程<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h3><h4 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h4><p>关于电梯的运作算法主要可能有ALS、SCAN、LOOK等，其实我个人在SCAN与LOOK中纠结了一下，但是鉴于往年学长统一的选择LOOK算法，我想这肯定是有道理的，便下定决心选择实现LOOK算法。</p><p>下面简单介绍一下LOOK算法：</p><ul><li>假定电梯处于某一层，且有一个特定的方向。</li><li>首先判断是否需要开门<ul><li>有人需要在该楼层下电梯</li><li>有人需要在该楼层进电梯</li></ul></li><li>然后判断电梯内部是否为空<ul><li>若不为空则往当前方向前进一步</li><li>再判断电梯是否有请求<ul><li>若电梯前方有请求则往当前运作方向前进一步</li><li>若电梯前方无请求则转向</li><li>若无请求则电梯进入睡眠状态</li></ul></li></ul></li></ul><p>所以getAdvice需要访问WaitTable维护的属性来确定电梯的下一步运作，所以在最外层套上对waitTable的synchronized块，实现代码大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Advice getAdvice() throws InterruptedException &#123;<br>        synchronized (this) &#123;<br>            if (sche != null) &#123;<br>                return Advice.SCHE;<br>            &#125;<br>            if (update != null) &#123;<br>                return Advice.UPDATE;<br>            &#125;<br><br>            if ((beRequested(floor, direction) &amp;&amp; inside.size() &lt; space) || canOut()) &#123;<br>                return Advice.OPEN;<br>            &#125; else if (!inside.isEmpty()) &#123;<br>                return Advice.MOVE;<br>            &#125; else &#123;<br>                if (isEmpty()) &#123;<br>                    if (isEnd()) &#123;<br>                        return Advice.END; //如果输入结束，电梯线程结束<br>                    &#125; else &#123;<br>                        if (sharing &amp;&amp; floor == transfer) &#123;<br>                            if (floor == top) &#123;<br>                                if (direction &gt; 0) &#123;<br>                                    return Advice.REVERSE;<br>                                &#125; else &#123;<br>                                    return Advice.MOVE;<br>                                &#125;<br>                            &#125; else if (floor == base) &#123;<br>                                if (direction &lt; 0) &#123;<br>                                    return Advice.REVERSE;<br>                                &#125; else &#123;<br>                                    return Advice.MOVE;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        this.wait();<br>                        return Advice.WAIT; //如果输入未结束，电梯线程等待<br>                    &#125;<br>                &#125; else &#123;<br>                    if (requestFront(floor, direction)) &#123;<br>                        return Advice.MOVE; //如果有请求发出地在电梯“前方”，则当前方向移动一层<br>                    &#125; else &#123;<br>                        return Advice.REVERSE; //电梯转向,不移动<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Dispatcher分派策略"><a href="#Dispatcher分派策略" class="headerlink" title="Dispatcher分派策略"></a>Dispatcher分派策略</h4><p>早已在刚进入计算机学院之处就听闻了影子电梯的大名，但是影子电梯需要同时获得六把锁，实现起来具有很大的风险，遂放弃，转而实现了随机分派策略。</p><p>随机分牌策略就是每一次分派时等可能的获得所想分派的电梯的id，然后仅需获得该电梯对应的WaitTable即可。但是在第二次和第三次作业中，电梯有可能处于特殊状态导致不能被分派，此时我们如果把所有请求分给空闲的电梯很有可能导致运行时间过长，为了解决这个问题让随机分派策略依然能进行下去，我设计了一种缓冲机制。</p><p>所谓缓冲机制，就是在电梯处于特殊状态时，不立即让这个电梯receive，而是存储在WaitTable的Buffer内，当电梯结束特殊状态后将Buffer清空并全部正式存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public synchronized void addBuffer(Person person) &#123;<br>     buffer.add(person);<br> &#125;<br> <br>synchronized (this) &#123;<br>        upDating = false;<br>        update = null;<br>        for (Person person : buffer) &#123;<br>            offer(person);<br>        &#125;<br>        buffer = new ArrayList&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DeBug方法"><a href="#DeBug方法" class="headerlink" title="DeBug方法"></a>DeBug方法</h2><h3 id="评测机的搭建"><a href="#评测机的搭建" class="headerlink" title="评测机的搭建"></a>评测机的搭建</h3><p>出于前几次作业没有做好评测而导致强测爆炸的惨痛经历，我在这单元充分的请教了D老师和G老师，将题目的指导书作为prompt，同时加入自己对于评测机的设计的思路，最终设计出了一个自动随机测试程序，遂用在了互测上，自动化评测房间里的同学，当出问题时就将对应的stdin和stdout信息保存下来，方便后续hack。</p><h3 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h3><p>光有评测机是远远不够的，处于多线程的随机性和无法调试性，我们很难直接从一般的输入输出信息发现自己程序的bug。受评论区大佬的启发，我单独开了一个DeBug类，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class DeBug &#123;<br>    public static boolean d() &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在程序中每个关键节点输出日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (DeBug.d()) &#123;<br>     System.out.println(&quot;[Log] + 相关信息&quot;))<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察日志信息，就让我发现了我在上文提到的最后一个电梯无法结束的bug，我发现日志没有所有电梯的end信息，便迅速察觉到了这个bug并立即做了修复。</p><h2 id="日后谈"><a href="#日后谈" class="headerlink" title="日后谈"></a>日后谈</h2><p>在三次作业中，我逐渐加深了对线程安全的理解和实践：</p><ul><li>理解原子操作与synchronized的使用场景：起初通过简单地给方法加 synchronized 来实现互斥，后来意识到应该精细控制锁的粒度，只在必要的代码块加锁，避免造成性能浪费。</li><li>掌握了wait-notify机制：在生产者消费者模型中，用 wait() 和 notifyAll() 控制线程的唤醒与阻塞，尤其注意了在循环中使用 wait 防止“假唤醒”问题。</li><li>避免死锁与线程长时间阻塞：在设计过程中不断检查线程可能卡死的点，像是线程 wait 后永远不被唤醒、或者电梯“长睡不起”等，尽量做到每一个线程都能有序启动与结束。</li><li>共享资源访问保护：每次访问共享数据结构如请求队列、缓冲区等都考虑到了线程竞争，并通过锁机制保证数据一致性。</li></ul><p>随着作业难度的提升，我也逐步建立起了模块化和分层的编程习惯：</p><ul><li>将电梯与调度逻辑解耦：电梯线程只负责执行动作，调度决策交给外部管理，使逻辑更清晰，便于扩展。</li><li>引入工厂模式和单例模式：将一些全局对象（如请求表）做成单例，把多个电梯或资源用工厂统一管理，避免重复创建，提高代码可维护性。</li><li>采用缓冲机制与共享区抽象：例如在 UPDATE 和 SCHE 等特殊状态下加入缓冲队列，保证调度器分派灵活不冲突；设计 SharedFloor 类集中管理共享楼层的进入与退出，简化了双轿厢访问控制。</li><li>输出日志与自测工具：为每一个模块加上日志输出、设计评测机进行压力测试，帮助在复杂的多线程环境中快速定位问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit1</title>
      <link href="/2025/03/20/ooUnit1/"/>
      <url>/2025/03/20/ooUnit1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>oo第一单元的任务是表达式括号展开与化简，课程组的目的在于通过这一十分结构化的任务来把我们引入面向对象的设计思想，并设计了三次迭代作业开发，旨在模拟真实的作业环境。</p><p>这一个月以来，确实在oo这门课上吃了不少苦，但通过自己的努力从第一次作业进C组到第三次作业强测无bug，互测只有一个bug，也学到了一些东西。通过这篇博客，本人将对自己的这三次代码进行详细分析，并做一些总结。</p><h1 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h1><p>第一次作业是对单变量（x）的多项式的展开。</p><h2 id="UML类图与架构设计"><a href="#UML类图与架构设计" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>本次作业代码的UML图如下</p><p><img src="/../images/hw1.jpg" alt="hw1"></p><h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><h3 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h3><p>这部分内容比较简单，我们沿用pre中hw7递归下降的做法，首先将<code>Input</code>传给<code>Lexer</code>，在<code>Lexer</code>建立的过程中，就完成了对各种符号的特异提取以及对变量（这里只有<code>x</code>）和数字的识别，并存储为一个<code>Token</code>串。然后将建立好的<code>Lexer</code>传递给<code>parser</code>。</p><p>我们第一次听说递归下降的时候可能会感到有些陌生。递归下降，在这里就是通过层层递归调用来完成对字符串<code>Input</code>的结构化建树，代码逻辑和建树的过程一致，自顶向下的建立好每一个分支。</p><p>我们这里需要建立的就是一个<code>Expression</code>的树，根节点是一个<code>Expr</code>，它由若干个子节点<code>Term</code>相加表述而成。同理，<code>Term</code>由若干个<code>Factor</code>相乘表述而成，若<code>Factor</code>是<code>Num</code>或者<code>Var</code>则递归到了终点，若为<code>ExprFactor</code>(一种特殊的<code>Factor</code>,内容是一个<code>Expr</code>)则跳到对<code>Expr</code>的解析。</p><p>所以代码中递归下降的核心就在于<code>parser</code>的<code>parseExpr()</code>中。</p><p>调用这个函数后会返回一个建立好的<code>Expr</code>，并交给下一步处理。</p><h3 id="括号展开"><a href="#括号展开" class="headerlink" title="括号展开"></a>括号展开</h3><p>这部分是本次作业的难点，我们需要将表达式展开为如下形式：</p><p>$$ E &#x3D; \sum ax^i $$</p><p>我们不难发现，这种形式的最小单元是一个单项式，于是我们建立<code>MiniTerm</code>类来描述这个最小单元（事实上一开始的实现并不好，代码结构混乱，也导致了很多的bug，我将在后面重构整个代码结构，但是大致的思路没什么问题）。<br>我们在类内部实现MiniTerm的乘法和加法的化简，来实现对括号的展开，由于会重构的原因，代码展示会放在后面的部分。</p><h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><h3 id="表达式解析-1"><a href="#表达式解析-1" class="headerlink" title="表达式解析"></a>表达式解析</h3><p>本部分沿用了pre的代码，这里就不再展开了。</p><h3 id="括号展开-1"><a href="#括号展开-1" class="headerlink" title="括号展开"></a>括号展开</h3><h4 id="重构前"><a href="#重构前" class="headerlink" title="重构前"></a>重构前</h4><p>其实可以发现在重构前，可以发现我的代码有两个主要的问题：</p><ul><li>Expr、Term和Factor内部的属性其实并不是真正的private的，存在大量的get方法将他们暴露在外，也导致了我的不良的代码结构和很多的bug。</li><li>建类混乱，没有清晰的层次结构。</li></ul><p>如，我对于展开后的表达式的结构化没有表示的很好，只有一个简单的最小单元类，事实上应该有一个多项式类来管理多项式乘法，将其与单项式加法区分开。</p><h4 id="重构后"><a href="#重构后" class="headerlink" title="重构后"></a>重构后</h4><p>首先是我重构后的UNL类图：</p><p><img src="/../images/hw1_re.png" alt="hw1_re"></p><p>可以发现，我对于解析包做了保留，主要在化简包上做了工作。</p><p>首先，我建立了一个静态的类<code>Simplifier</code>，它内部的函数<code>simplifyExpr(Expr expr)</code>会将传进来的expr按层次解析：</p><pre><code>public static Poly simplifyExpr(Expr expresiton) &#123;    Poly result = new Poly();    for (int i = 0; i &lt; expresiton.amount(); i = i + 1) &#123;        Term term = expresiton.getTerm(i);        Poly termPoly = simplifyTerm(term);        result = Poly.addPoly(result, termPoly);    &#125;    return result;&#125;public static Poly simplifyTerm(Term term) &#123;    Poly result = new Poly();    for (int i = 0; i &lt; term.amount(); i = i + 1) &#123;        Factor factor = term.getFactor(i);        Poly factorPoly = simplifyFactor(factor);        result = Poly.multPoly(result, factorPoly);    &#125;    return result;&#125;public static Poly simplifyFactor(Factor factor) &#123;    return factor.toPoly();&#125;</code></pre><p>把解析的过程完全脱离于其他工作，代码结构清晰了不少。</p><p>我们可以发现在<code>simplifyFactor(Factor factor)</code>调用了<code>toPoly()</code>方法，这就要引入我们的Poly类了。<br>主要属性如下：</p><pre><code>private HashMap&lt;Unit, BigInteger&gt; units;private ArrayList&lt;Unit&gt; flag;</code></pre><p>其中units用来储存这次作业的最小单元：单项式和对于的幂；flag用来储存units中的Key，主要作用是在后期取值时保护属性不暴露在外，也方便索引unit。</p><p>然后我们在Poly中实现了对Unit的加法：</p><pre><code>public void addUnit(Unit m, BigInteger c) &#123;    Unit newM = m.check();    if (units.containsKey(newM)) &#123;        BigInteger coe = units.get(newM);        coe = coe.add(c);        if (coe.equals(BigInteger.ZERO)) &#123;            units.remove(newM);            flag.remove(newM);            if (!units.containsKey(Unit.ONE)) &#123;                units.put(Unit.ONE, BigInteger.ZERO);//保留常数项                flag.add(Unit.ONE);            &#125;        &#125;        units.replace(newM, coe);    &#125; else &#123;        units.put(newM, c);        flag.add(newM);    &#125;&#125;</code></pre><p>还实现了对Poly的乘法和加法：</p><pre><code>public static Poly multPoly(Poly poly1, Poly poly2) &#123;    if (poly1.amount() == 0) &#123;        return poly2;    &#125;    if (poly2.amount() == 0) &#123;        return poly1;    &#125;    Poly result = new Poly();    for (Unit unit1 : poly1.units.keySet()) &#123;        for (Unit unit2 : poly2.units.keySet()) &#123;            //...        &#125;    &#125;    return result;&#125;public static Poly addPoly(Poly poly1, Poly poly2) &#123;    Poly result = new Poly();    for (Unit unit : poly1.units.keySet()) &#123;        result.addUnit(unit, poly1.units.get(unit));    &#125;    for (Unit unit : poly2.units.keySet()) &#123;        result.addUnit(unit, poly2.units.get(unit));    &#125;    return result;&#125;</code></pre><p>在以上的运算中始终保持最终的返回结果是最简的。</p><p>这样之后，我们就可以在Factor中每一个类都写一个toPoly方法，并层层向上传递，当传到顶层的时候就构建好了我们所需要的没有括号的表达式结构了。</p><p>这次重构给我带来的感受很多，主要有以下几点：</p><ul><li>不要为了优化代码量和代码性能而丧失代码的结构性和可读性。</li><li>对于一个类的内容的处理要在对应的类中写一个方法来实现，并返回最终的结果。这样既减少了代码的耦合性，又增加了代码的可读性。</li></ul><h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><h2 id="UML类图与架构设计-1"><a href="#UML类图与架构设计-1" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>如下：</p><p><img src="/../images/hw2.png" alt="hw2"></p><h2 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>第二次作业新增的内容是括号嵌套、递归自定义函数和三角函数因子。</p><p>由于我在上一次作业已经实现了括号嵌套（ExprFactor递归到Expr）所以这次作业我将就三角函数因子和自定义递归函数的处理讲解。</p><h3 id="三角函数因子"><a href="#三角函数因子" class="headerlink" title="三角函数因子"></a>三角函数因子</h3><p>这部分内容比较简单，我们首先需要在Factor接口新增两个实现即可，分别是<code>SinFactor</code>和<code>CosFactor</code>，并实现其<code>toPoly()</code>方法。</p><p>其次需要改写<code>Unit</code>，新增如下属性</p><pre><code>private ArrayList&lt;Poly&gt; sinPolys;private HashMap&lt;Poly, BigInteger&gt; sinFactors;private ArrayList&lt;Poly&gt; cosPolys;private HashMap&lt;Poly, BigInteger&gt; cosFactors;</code></pre><p>并改写Poly和Unit的乘法加法逻辑即可，就可以完成三角函数因子这部分内容。</p><p>要注意的是三角函数因子内部存储的内容是因子。</p><h3 id="递归自定义函数"><a href="#递归自定义函数" class="headerlink" title="递归自定义函数"></a>递归自定义函数</h3><p>说实话，这部分内容花了我很大一部分心思，我初期苦恼于如何有效的存储自定义函数和调用自定义函数。</p><p>经过一天的思考后我的解决方案是沿用递归下降的思路遍历<code>Expr</code>树：</p><p>1.新建一个<code>Function</code>类，类内部的属性为：</p><pre><code>private final String name;//函数名private final ArrayList&lt;String&gt; paras;//形参列表private final BigInteger coeFunc1;//n-1项的系数private final ArrayList&lt;Expr&gt; paraFunc1; //n-1项的实参形式，用Expr储存private final BigInteger coeFunc2;//n-2项的系数private final ArrayList&lt;Expr&gt; paraFunc2; //n-2项的实参形式，用Expr储存private final Expr func0;//0项的形参表达式private final Expr func1;//1项的形参表达式private final Expr expression;//函数表达式</code></pre><p>2.新建一个静态<code>SolveFunc</code>类存储已经定义好的函数，用函数名索引<code>Function</code>存在HashMap中，处理传入的<code>Expr</code>，替换所有的<code>FuncFactor</code>后返回新的<code>Expr</code>。内部方法如下：</p><pre><code>public static Expr solveExpr(Expr expr) &#123;    Expr newExpr = new Expr();    for (int i = 0; i &lt; expr.amount(); i += 1) &#123;        Term term = expr.getTerm(i);        term = solveTerm(term);        newExpr.addTerm(term);    &#125;    return newExpr;&#125;public static Term solveTerm(Term term) &#123;    Term newTerm = new Term();    for (int i = 0; i &lt; term.amount(); i += 1) &#123;        Factor factor = term.getFactor(i);        newTerm.addFactor(solveFactor(factor));    &#125;    return newTerm;&#125;public static Factor solveFactor(Factor factor) &#123;    return factor.solveFunc();&#125;</code></pre><p>3.在所有<code>Factor</code>中实现对<code>FuncFactor</code>的处理，以实现替换书上的所有<code>FuncFactor</code>节点。</p><p>具体逻辑是遍历树上的每一个<code>Factor</code>节点，若遇上<code>FuncFactor</code>则调用<code>Function.call()</code>并传入该函数因子的信息，替换的逻辑中也沿用了<strong>递归下降</strong>的想法，先自顶向下构建好待替换的<code>Expr</code>(设计斐波那契递归,层层计算<code>n-1</code>项<code>Expr</code>和<code>n-2</code>项<code>Expr</code>然后相加返回到上一层)，然后包装成<code>ExprFactor</code>后放入<code>FuncFactor</code>的位置即可。<br>经过上述操作后，<code>Expr</code>没有了<code>FuncFactor</code>节点，传给<code>Simplifier</code>进行括号展开即可。</p><h2 id="Poly和Unit的新增内容"><a href="#Poly和Unit的新增内容" class="headerlink" title="Poly和Unit的新增内容"></a>Poly和Unit的新增内容</h2><p>本次作业的最小单元不再是 $ax^n$ 而是 $ ax^n\prod_{i}sin(Factor_i)\prod_{i}cos(Factor_i)$<br>所以我们只需要改写一下加法和乘法的逻辑保证依然在计算的过程中是最简的即可。</p><h1 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h1><h2 id="UML类图与架构设计-2"><a href="#UML类图与架构设计-2" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>如下：</p><p><img src="/../images/hw3.png" alt="hw3"></p><h2 id="代码架构分析-1"><a href="#代码架构分析-1" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>可以发现，第三次作业的UML类图相比较于第二次作业的UML类图几乎没什么改动，一方面是因为这次作业的新增内容只有求导因子和自定义普通函数，另一方面是因为在第一次重构后我的代码的架构的优良。<br>由此也是第一次尝到了架构好的甜处。</p><h2 id="自定义普通函数"><a href="#自定义普通函数" class="headerlink" title="自定义普通函数"></a>自定义普通函数</h2><p>由于上一次作业已经实现了自定义递归函数，那我们也可以把自定义普通函数归于此，只需要把它看作递归深度为0的自定义递归函数即可，call时直接返回储存的0项表达式。</p><h2 id="求导因子"><a href="#求导因子" class="headerlink" title="求导因子"></a>求导因子</h2><p>第一步和第二次作业一样，先增加求导因子实现Factor这个接口。我们不难发现，实现求导的过程其实和替换FuncFactor的过程是可以很相似的，我们只需要一样的遍历整个树，当发现求导因子时，就递归的构建起表达式即可，这部分实现，我们放在了DerFactor里，代码结构如下：</p><pre><code>//SolveDer内容public static Expr solveExpr(Expr expr) &#123;    Expr newExpr = new Expr();    for (int i = 0; i &lt; expr.amount(); i += 1) &#123;        Term term = expr.getTerm(i);        term = solveTerm(term);        newExpr.addTerm(term);    &#125;    return newExpr;&#125;public static Term solveTerm(Term term) &#123;    Term newTerm = new Term();    for (int i = 0; i &lt; term.amount(); i += 1) &#123;        Factor factor = term.getFactor(i);        newTerm.addFactor(solveFactor(factor));    &#125;    return newTerm;&#125;public static Factor solveFactor(Factor factor) &#123;    return factor.solveDer();&#125;//DerFactor内容@Overridepublic Factor solveDer() &#123;    Expr newExpr = SolveDer.solveExpr(expr);//先解决expr的dx    newExpr = (Expr) newExpr.derive(); // expr.derive返回的是表达式    return new ExprFactor(newExpr, coe, exp);&#125;</code></pre><p>然后这次作业就很简单的被我们完成了。（好耶！！</p><h1 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h1><p>很不幸，本人在Unit1出现了许多的bug，让我们来一一分析一下bug的原因。</p><h2 id="HW1"><a href="#HW1" class="headerlink" title="HW1"></a>HW1</h2><p>在上文我们已经说过，第一作业的bug大多因为架构的不合理和代码风格的差劲。</p><p>那么不合理之处在哪呢？<br>1.类之间的耦合度高，没有做到把任务分解简化，而是让同一块处理多个混合的任务，非常容易导致bug。<br>下面就是hw1改写前的一些代码指标：</p><p><img src="/../images/hw1_%E6%8C%87%E6%A0%871%20.png" alt="指标1"></p><p>从左至右分别为OCavg Ocmax WMC</p><p><img src="/../images/hw1_%E6%8C%87%E6%A0%872.png" alt="指标2"></p><p>从左至右分别为Cogc ec(G) iv(G) v(G)</p><p>我们可以很明显的看出计算类和主类在多个指标中出现了不合理的数值，这明显是有缺陷的。</p><p>而在重构之后：</p><p><img src="/../images/hw1re.png" alt="hw1_re_指标"></p><p>计算类的指标好了许多，直观上我们也能感受到代码架构上的清晰化。</p><h2 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a>hw2</h2><p>第二次作业的bug主要是因为一处遗漏而导致的meg恶行bug，在强测多个点都出现了这个bug，在bug修复中修好后就大部分通过了。</p><p>另外一小部分是在优化中出了问题，这告诉我们优化需谨慎！！！</p><p>下面是hw2的一些指标</p><p><img src="/../images/hw2_%E6%8C%87%E6%A0%87.png" alt="hw2_指标"></p><p><img src="/../images/hw1re.png" alt="hw2_指标"></p><h2 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a>hw3</h2><p>第三次作业的bug是因为一处笔误导致的bug，这里就不展开描述了。</p><p><img src="/../images/hw2_%E6%8C%87%E6%A0%87.png" alt="hw3_指标"></p><p><img src="/../images/hw1re.png" alt="hw3_指标"></p><p><img src="/../images/hw3_%E6%8C%87%E6%A0%87.png" alt="hw3_指标"></p><h2 id="指标展现的优点"><a href="#指标展现的优点" class="headerlink" title="指标展现的优点"></a>指标展现的优点</h2><p>首先我的代码的耦合程度相较于我身边的同学是比较低的，我将各个任务分散到不同的模块中，从string到Expr的转换，处理FuncFactor，处理DerFactor，构建多项式并输出都是由独立的模块负责，并且将来如果有新的因子和处理，我还可以通过增添新的模块来完成这个任务，我的代码也因此可读性很高，也十分方便定位bug。</p><h2 id="指标展现的缺点"><a href="#指标展现的缺点" class="headerlink" title="指标展现的缺点"></a>指标展现的缺点</h2><p>但是由于上面不断的增添模块，如果需求越来越多，我的代码量也会越来越多，这将变得不利于维护。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本单元的优化我做的比较简单，主要集中在三角函数的合并优化。<br>首先是合并同类项，我重写了Expr、Term和Factor的HashCode和equals方法，这使得我判断两个Unit是否是同样的变得很简单，只需要调用containsKey()判断是否已经在Poly里即可。</p><p>但是这样还有一个问题，就是如果sin或者cos内的factor正好相差一个-1的系数呢？这个问题要完全解决比较苦难，所以我选择根据sin或cos里Poly的第一个Unit的符号做判断，如果是负号，那我选择将负号提到外面，这样一来即没有增添很多的代码，又能大大提高同类项的识别与合并概率。</p><h1 id="发现别人程序bug所采用的策略"><a href="#发现别人程序bug所采用的策略" class="headerlink" title="发现别人程序bug所采用的策略"></a>发现别人程序bug所采用的策略</h1><p>在经历hw2的惨痛教训后（没有好好评测自己的代码），我决定自己搭建一台评测机（主要是请教ChatGpt老师和DeepSeek老师）我让生成式人工智能为我写了一份评测数据的生成脚本，然后交给我自己写的自动化对拍程序，将互测小组内的成员的代码去跑我生成的评测数据并进行对拍，将不一致的结果记录下来，然后为了避免是同质的Bug，选择帮他们修复并重新评测。<br>这就是我这次hack采取的策略，但是不足的是，生成评测数据的脚本不是很强，并没有为我测处太多的bug，但好在为我自己的强测带来了很多好处。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ul><li><strong>写代码前先思考</strong> ： 如果啥都没想好就开写代码，那么这段代码一定会重构。</li><li><strong>多看学长学姐博客</strong> ： 学习前人经验和优秀的架构是一种好习惯，有时还能启发自己的新思路。</li><li><strong>注意代码的可读性和可拓展性</strong> ：千万不要为了代码量和编写方便而放弃代码的可读性，同时，这次Unit1的迭代开发经验还启示我一定要注意可拓展性。</li><li><strong>写代码时多关注代码指标</strong> ： 如果你发现自己的耦合度或者什么其他指标超标时，那么你就需要改一改你的架构了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2025/03/20/%E5%BC%80%E7%AF%87/"/>
      <url>/2025/03/20/%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="哇咔咔"><a href="#哇咔咔" class="headerlink" title="哇咔咔"></a>哇咔咔</h2><p><img src="/../images/%E9%94%A6%E9%B2%A4.jpg" alt="锦鲤"></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $^%@#!~ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单的自我介绍"><a href="#简单的自我介绍" class="headerlink" title="简单的自我介绍"></a>简单的自我介绍</h2><p>一个爱摸鱼但是也想发paper的北航计算机学生。</p><h2 id="为什么开这个博客"><a href="#为什么开这个博客" class="headerlink" title="为什么开这个博客"></a>为什么开这个博客</h2><p>想记录一下自己的生活（总不能让自己存在的唯一证明是留在沙发上的屁股印吧）</p><h2 id="我的联系方式"><a href="#我的联系方式" class="headerlink" title="我的联系方式"></a>我的联系方式</h2><ul><li>个人邮箱：<a href="mailto:&#x4a;&#x63;&#x68;&#x31;&#x38;&#50;&#x39;&#55;&#x34;&#57;&#57;&#x36;&#x36;&#53;&#x40;&#x62;&#117;&#x61;&#97;&#46;&#x65;&#x64;&#117;&#x2e;&#x63;&#110;">&#x4a;&#x63;&#x68;&#x31;&#x38;&#50;&#x39;&#55;&#x34;&#57;&#57;&#x36;&#x36;&#53;&#x40;&#x62;&#117;&#x61;&#97;&#46;&#x65;&#x64;&#117;&#x2e;&#x63;&#110;</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
