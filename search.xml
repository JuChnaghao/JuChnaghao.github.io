<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ooUnit4</title>
      <link href="/2025/06/14/ooUnit4/"/>
      <url>/2025/06/14/ooUnit4/</url>
      
        <content type="html"><![CDATA[<h1 id="UML及oo总结"><a href="#UML及oo总结" class="headerlink" title="UML及oo总结"></a>UML及oo总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>仿佛是昨天，我还在de第一单元多项式的bug，回忆起Unit1的痛苦经历，再看到Unit4满分（难度不一样哈哈哈，不过也确实是成长了），感慨万分，可能是因为oo让我这个学期过于充实了吧，所以感觉是如此的快，要和oo告一段落了。</p><h2 id="UML正向建模与开发"><a href="#UML正向建模与开发" class="headerlink" title="UML正向建模与开发"></a>UML正向建模与开发</h2><p>在本单元，我们实践了先进行UML图的建模再根据UML图来构建自己的代码的过程，三次作业分别让我们画了UML类图、状态图和时序图。</p><p>UML正向建模给我的第一印象是比直接写code要复杂的，究其原因肯定在于我们的项目比较简单，当项目的初始规模非常复杂后，UML的作用就能体现出来了，这个单元前两次作业我耐着性子先画出了UML图再进行代码的编写的，以体会UML的价值所在。提前设计好类并构想好关键类的协作与状态转变，其实相当于把以前写代码时边写边想的过程分离了，这个思想感觉也有些面向对象的感觉哈哈哈。<br>我们在设计的时候只需要保证设计的合理与正确即可，写code的时候也只需要保证代码符合设计并且不出错即可。这样设计与实现分离的想法为复杂工程带来了可能性。写代码时可能会遇见初始设计不合理的地方，这时就要停止code的工作去更改设计，然后再继续进行code的编写。</p><p>UML图在测试时也给我们提供了方向，我们还可以测试code与UML模型之间的统一性。</p><h2 id="架构设计与统一性"><a href="#架构设计与统一性" class="headerlink" title="架构设计与统一性"></a>架构设计与统一性</h2><p>下面是我这单元的UML类图和UML状态图以及对应的代码（时序图画的过于简单就不展示了）</p><p>首先是UML类图：<br><img src="/../images/UML%E7%B1%BB%E5%9B%BE.png" alt="img.png"><br>对应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Library &#123;<br>    private BookShelf bookShelf = new BookShelf();<br>    private BookShelf hotBookShelf = new BookShelf();<br>    private HashSet&lt;LibraryBookIsbn&gt; toBeHot = new HashSet&lt;&gt;();<br>    private HashSet&lt;Book&gt; bro = new HashSet&lt;&gt;();<br>    private HashMap&lt;String, ReserveOrder&gt; ao = new HashMap&lt;&gt;(); //stuId-order<br>    private ArrayDeque&lt;ReserveOrder&gt; orderDeque = new ArrayDeque&lt;&gt;();<br>    private HashSet&lt;String&gt; hadOrderdIds = new HashSet&lt;&gt;();<br>    private HashMap&lt;String, Book&gt; rr = new HashMap&lt;&gt;(); //stuId-Book<br>    private HashMap&lt;LibraryBookId, Book&gt; books = new HashMap&lt;&gt;();<br>    private HashMap&lt;String, User&gt; users = new HashMap&lt;&gt;(); //stuId-User<br>    private HashMap&lt;LibraryBookId, Pair&lt;LocalDate, String&gt;&gt; borrowedBooks = new HashMap&lt;&gt;();<br>    private LocalDate lastOpen = null;<br>    operations...<br>&#125;<br>public class Book &#123;<br>    private LibraryBookId id;<br>    private LibraryBookState state = LibraryBookState.BOOKSHELF;<br>    private ArrayDeque&lt;LibraryTrace&gt; deque = new ArrayDeque&lt;&gt;();<br>    private int due;<br>    operations...<br>&#125;<br>public class BookShelf &#123;<br>    private HashMap&lt;LibraryBookIsbn, HashMap&lt;LibraryBookId, Book&gt;&gt; bookShelf = new HashMap&lt;&gt;();<br>    operations...<br>&#125;<br>public class User &#123;<br>    private String stuId;<br>    private Book bbook;<br>    private HashMap&lt;LibraryBookIsbn, Book&gt; cbooks;<br>    private int credit;<br>    operations...<br>&#125;<br>public class ReserveOrder &#123;<br>    private String usrId;<br>    private LibraryBookIsbn isbn;<br>    private Book book;<br>    private LocalDate date;<br>    operations...<br>&#125;<br></code></pre></td></tr></table></figure><p>我对这次作业的图书馆系统设计了几个关键的类，首先是Book、Library、User，这三个类是最容易抽象出来的，所承担的任务也是最重的，Library负责接受各种命令，User和Book负责和Library交互。<br>同时为了方便管理Book，我还设计了一个BookShelf类，对外提供简介的拿取和放置接口。<br>为了简洁的实现预约功能，我还抽象了一个Order类负责记录各种预约的信息，方便查询和过期处理。</p><p>然后是UML状态图：<br><img src="/../images/UML%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="img.png"></p><p>和对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Trigger(from = &quot;InitState&quot;, to = &quot;BookShelf&quot;)<br>@Trigger(from = &quot;BookShelf&quot;, to = &#123;&quot;User&quot;, &quot;HotBookShelf&quot;, &quot;AppointmentOffice&quot;, &quot;ReadRoom&quot;&#125;)<br>@Trigger(from = &quot;User&quot;, to = &quot;BorrowReturnOffice&quot;)<br>@Trigger(from = &quot;HotBookShelf&quot;, to = &#123;&quot;User&quot;, &quot;BookShelf&quot;, &quot;AppointmentOffice&quot;, &quot;ReadRoom&quot;&#125;)<br>@Trigger(from = &quot;Appointment Office&quot;, to = &quot;BookShelf&quot;)<br>@Trigger(from = &quot;BorrowReturnOffice&quot;, to = &quot;BookShelf&quot;)<br>@Trigger(from = &quot;ReadRoom&quot;, to = &quot;BorrowReturnOffice&quot;)<br>public void move(LocalDate date, LibraryBookState nextState) &#123;<br>    LibraryTrace trace = new LibraryTrace(date, state, nextState);<br>    deque.addLast(trace);<br>    state = nextState;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的Book的状态转移很简单，就是一个move，参数有下一个状态，Book内部记录当前状态，改变当前状态时会记录下这次转移，方便下次查询。</p><p>Book的状态其实就是Book处于什么位置，Book可能出现的位置有：BookShelf、User、AO、BRO、RR、HotBookShelf，一一注意即可。</p><p>UML时序图我画的非常简单，就不展示了。</p><h2 id="大模型辅助正向建模体验"><a href="#大模型辅助正向建模体验" class="headerlink" title="大模型辅助正向建模体验"></a>大模型辅助正向建模体验</h2><p>本次作业助教创新性的引导我们使用大模型来帮我们辅助正向建模。</p><p>用好大模型不是把指导书全丢给他就行了，因为大模型对于业务的理解能力非常差，而要用好大模型，我们就做到对指导书的理解，然后让大模型发挥它的长处（补全）</p><p>大模型补全能力是非常强的，我们只需要加以提示和引导就能构建一个不错的模型。在对于指导书的理解的基础上，给出自己模型的框架，比如需要有什么类，类里有什么基础的属性和方法，承担了什么功能，把这些描述好后让大模型去“补全”就能得到初版，这已经为我们节省了很多的工作，同时我们的思路也能得到新的启发。</p><h2 id="四个单元中架构设计思维的演进与四个单元中测试思维的演进"><a href="#四个单元中架构设计思维的演进与四个单元中测试思维的演进" class="headerlink" title="四个单元中架构设计思维的演进与四个单元中测试思维的演进"></a>四个单元中架构设计思维的演进与四个单元中测试思维的演进</h2><h3 id="设计思维"><a href="#设计思维" class="headerlink" title="设计思维"></a>设计思维</h3><p>首先讲讲设计思维的变化<br>由于oopre的作用，我在接触第一单元时没有那么的吃力，但是现在回顾起当时的设计，还是觉得非常丑陋的，也因此吃了设计不好的亏，第一单元错了很多。<br>一开始只知道要设计类，但是并没有太注意类之间的协作，同时为了实现简介干净，还需要理解封装的重要性。到了第四单元，这些已经改善了许多。<br>然后是一开始是想一出是一出，在屎山上不断的打补丁，这也是非常不好的，首先要做好初步的设计，然后每次迭代都要在原有的设计上重新设计再去code。</p><h3 id="测试思维"><a href="#测试思维" class="headerlink" title="测试思维"></a>测试思维</h3><p>java有两种测试方法<br>一种是面向评测机的测试（bushi，另外一种是写单元测试那一套。<br>第一单元我还不知道测试的重要性，过了中测就没管了，果然强测惨不忍睹。<br>后来我学会了搭建评测机，但是自己编写的实在太简单了，又引入了大模型的帮助，来帮我完善评测机的功能。<br>在JML一章，我还领略了单元测试的强大，在设计上针对每一处做好测试，基本能保证最后的功能正确。</p><h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><p>在oo这门课上我最大的收获是抗压能力变强了，学期初在oo上栽了一个大跟头，但也慢慢的调整了过来，没有脱离大部队的脚步。</p><p>然后是我通过oo这门课学会了工业中存在“设计”这门“艺术”，像荣老师所说，至少知其然也浅浅的知其所以然，算是踏上了成为一名合格的程序员的第一步。</p><p>在此感谢oo这一学期的陪伴，感谢老师与助教的工作！也希望自己能成为oo助教，为课程组带了新的东西！</p>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit3</title>
      <link href="/2025/05/18/ooUnit3/"/>
      <url>/2025/05/18/ooUnit3/</url>
      
        <content type="html"><![CDATA[<h1 id="JML规格化设计"><a href="#JML规格化设计" class="headerlink" title="JML规格化设计"></a>JML规格化设计</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元作业是一个助教辛苦，学生幸福的单元，首先感谢助教对于JML的接口规格化设计。</p><h2 id="第三单元测试过程"><a href="#第三单元测试过程" class="headerlink" title="第三单元测试过程"></a>第三单元测试过程</h2><h3 id="对测试的理解"><a href="#对测试的理解" class="headerlink" title="对测试的理解"></a>对测试的理解</h3><ol><li>单元测试，目标：验证最小功能单元（函数、类）是否按预期运行。</li><li>功能测试，目标：验证功能是否符合需求规格。</li><li>集成测试，目标：验证多个模块组合后的协同工作是否正常。</li><li>压力测试，目标：测试系统在高负载、大数据量下是否稳定、性能合理。</li><li>回归测试，目标：确保旧功能在新版本中仍然正确。</li></ol><h3 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h3><ol><li><p>状态跟踪使用 existing_person_ids、existing_relations 等集合保存已创建实体，确保生成的命令多数为有效命令；避免了生成无效命令浪费测试机会。</p></li><li><p>概率控制 每次生成 ID 时有 80% 以上概率使用已存在的 ID，20% 左右概率生成不存在的 ID，用于测试非法输入处理； 保证测试“有效性 + 鲁棒性”兼备。</p></li><li><p>模块覆盖与比例平衡明确控制三大模块（HW1、HW2、HW3）的命令分布权重；比如HW3权重更高（如 am、aem），适应后期重点测试。</p></li><li><p>边界情况生成比如 ID 范围为 [-100, 100]，年龄范围为 [1, 200]； 使用不同数据长度（如随机生成长度 1~100 的名字）。</p></li><li><p>指令生成路径，按照一定的策略随机的生成指定数量的指令，负责测试程序的不同功能。</p></li></ol><h2 id="大模型辅助"><a href="#大模型辅助" class="headerlink" title="大模型辅助"></a>大模型辅助</h2><h3 id="一、整体策略：从“提问者”到“指挥者”"><a href="#一、整体策略：从“提问者”到“指挥者”" class="headerlink" title="一、整体策略：从“提问者”到“指挥者”"></a>一、整体策略：从“提问者”到“指挥者”</h3><p>大模型的强项是语言理解与上下文记忆，而不是通灵。要发挥其最大效能，关键在于你如何设计任务结构、输入信息与交互节奏。可遵循以下三步法：</p><ul><li><p>目标清晰（What）明确告诉模型你要做什么，如：“我正在开发一个评测机，请帮我生成合理的测试用例生成器。”</p></li><li><p>约束充分（How）提供必要背景与规则：输入格式、限制条件、边界值、接口定义、已有类说明等。</p></li><li><p>拆解合理（Step by step）将复杂任务拆解为子任务，让模型逐步完成（如先写接口草图，再实现核心函数，最后补充状态维护）。</p></li></ul><h3 id="二、不同典型场景下的引导技巧"><a href="#二、不同典型场景下的引导技巧" class="headerlink" title="二、不同典型场景下的引导技巧"></a>二、不同典型场景下的引导技巧</h3><h4 id="场景一：规格化设计（接口与架构）"><a href="#场景一：规格化设计（接口与架构）" class="headerlink" title="场景一：规格化设计（接口与架构）"></a>场景一：规格化设计（接口与架构）</h4><p>目标：设计合理的类、方法、数据结构</p><p>引导技巧：</p><p>明确提出功能要求（如“实现一个支持动态添加好友、标签的社交网络类”）</p><p>说明输入输出格式（如命令格式 ap id name age）</p><p>提供已有组件（如你已有的 Person 类定义）</p><p>可用 prompt 模板示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">我希望你帮我设计一个 Java 类 `Network`，它支持以下命令：<br>- `ap id name age`：添加用户<br>- `ar id1 id2 val`：建立关系<br>  这个类应该如何设计接口？需要哪些内部数据结构？<br></code></pre></td></tr></table></figure><h4 id="场景二：代码实现（核心算法、状态维护）"><a href="#场景二：代码实现（核心算法、状态维护）" class="headerlink" title="场景二：代码实现（核心算法、状态维护）"></a>场景二：代码实现（核心算法、状态维护）</h4><p>目标：写出能工作的函数&#x2F;类</p><p>引导技巧：</p><p>提供函数签名与预期行为（如“输入为命令列表，输出为处理结果”）</p><p>提供已有代码片段、类定义供调用</p><p>可示例性描述一些关键输入输出</p><p>若模型写的第一版不够精确，可反复对细节提问并要求“逐行解释你的代码”</p><h4 id="场景三：测试与验证"><a href="#场景三：测试与验证" class="headerlink" title="场景三：测试与验证"></a>场景三：测试与验证</h4><p>目标：构造测试用例，验证正确性</p><p>引导技巧：</p><p>给出你期望测试的函数或命令格式（如 “qv id1 id2”）</p><p>明确边界（如“我要测试最大长度字符串输入”）</p><p>命令示例 + 状态约束（如“已存在的 ID 集合是 {1, 2, 3}，请生成合法但边界的 mr 命令”）</p><h4 id="场景四：优化与分析"><a href="#场景四：优化与分析" class="headerlink" title="场景四：优化与分析"></a>场景四：优化与分析</h4><p>目标：让模型分析瓶颈、重构代码或提出设计优化建议</p><p>引导技巧：</p><p>提供当前实现代码 + 描述性能瓶颈</p><p>提出明确优化目标（如“将当前 getValueSum() 从 O(n) 降为 O(1)”）</p><p>要求模型分析时提供理由，不仅是结论</p><h2 id="关键数据结构和算法设计"><a href="#关键数据结构和算法设计" class="headerlink" title="关键数据结构和算法设计"></a>关键数据结构和算法设计</h2><h3 id="hw9"><a href="#hw9" class="headerlink" title="hw9"></a>hw9</h3><p>Person:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Person implements PersonInterface &#123;<br>    private String name;<br>    private int age;<br>    private int id;<br>    private HashMap&lt;Integer, PersonInterface&gt; acquaintance;<br>    private HashMap&lt;Integer, PersonValuePair&gt; values;<br>    private HashMap&lt;Integer, TagInterface&gt; tags;<br>    private TreeSet&lt;PersonValuePair&gt; ts = new TreeSet&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便查询acquaintance，使用了复杂度为O(1)的HashMap来存储Person的好友。</p><p>本次作业中，Person需要注重考虑优化getBestAcquaintance()方法，于是我采用了java自己的treeSet来实现O(logn)维护，O(1)查询，只需要重写Set中元素的compareTo()方法即可线上维护value的顺序。</p><p>Tag:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Tag implements TagInterface &#123;<br>    private int id;<br>    private HashMap&lt;Integer, PersonInterface&gt; persons;<br>    private int sum = 0;<br>    private int sum2 = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>本次作业Tag需要注意的点是getAgeMean()和getAgeVar()，本人同样实现了O(1)维护，O(1)查询的方法，只需要维护好value和以及value^2和即可。</p><p>NetWork:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Network implements NetworkInterface &#123;<br>    private HashMap&lt;Integer, PersonInterface&gt; persons;<br>    private int triple = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>NetWork的难点主要体现在查询三元环数量以及连通性查询</p><p>关于三元环的查询，我选择维护一个triple变量，在每一次加边和删边操作时进行O(N)的维护，实测效果很好。</p><p>关于连通性查询，我见许多同学使用了并查集这个数据结构，但是本次作业中涉及到了删边操作，但是并查集并不支持删边后的查询，于是只能重建，鉴于实现起来过于复杂，我选择了BFS查询连通性，这一算法在后续接口中也会使用，只能说性价比极高。</p><h3 id="hw10"><a href="#hw10" class="headerlink" title="hw10"></a>hw10</h3><p>新增类OfficialAccount：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class OfficialAccount implements OfficialAccountInterface &#123;<br>    private int ownerId;<br>    private int id;<br>    private String name;<br>    private HashMap&lt;Integer, PersonInterface&gt; followers;<br>    private HashMap&lt;Integer, PersonInterface&gt; articles;<br>    private HashMap&lt;Integer, PersonValuePair&gt; contributions;<br>    private TreeSet&lt;PersonValuePair&gt; ts;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是本次作业新增的类OfficialAccount，主要负责维护公众号的关注者和文章（仅关注ID）以及相应关注者的贡献。</p><p>需要注意的地方只有一个接口getBestContributor()，所以我们选择和上次作业一样的做法，用TreeSet来维护贡献的有序性，然后就可以很快的查询最佳贡献者了。</p><p>Person改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class Person implements PersonInterface &#123;<br>    private TreeMap&lt;Integer, Integer&gt; receivedArticles;<br>    private HashMap&lt;Integer, Integer&gt; articles;<br>    private HashMap&lt;PersonValuePair, TagInterface&gt; otherTags;<br>    private int order = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要维护Person收到的文章以及他们接受的顺序，由于在这一次作业中不可能出现一个人多次接受同一篇文章，所以我们用Map来存储article。</p><p>但是问题来了，我们怎么维护文章的接受顺序呢？没错，又是TreeMap，我们在Person里维护一个取号机制，来一篇文章取一个号，同时号码减一，然后利用TreeMap能维护Key的顺序的机制，我们就能维护好文章的顺序啦，先进来的文章取得号一定大于后进来的文章。</p><p>我们还注意到我维护了一个otherTags，这其实是为了Network里的一个接口服务的，这里暂不讲解。</p><p>Tag改动：</p><p>Tag新增了一个对于内部Person之间value和的查询，但是这个实现主要是在Network中维护的，所以不在这里讲解了。</p><p>Network改动：</p><p>新增了双元环数量的查询（当一对Perosn互为最好的朋友时就视为一个双元环），这个维护方法和三元环类似，主要是在网络中加边删边时正确更改即可。</p><p>新增了对于TagValueSum的查询，注意到我在Person里维护了Person被归类的Tag，这样就可以在更改关系时查询会涉及到哪些Tag的valueSum，然后一一线上维护即可。</p><p>新增了最短路径的接口，我们采用了BFS的实现，简单高效。</p><h3 id="hw11"><a href="#hw11" class="headerlink" title="hw11"></a>hw11</h3><p>本次作业的改动主要为新增了Message类，Message承担了转发文章（被转发的人会接受），发红包（更改Person的Money值），发表情包的作用，同时会增加转发于被转发者的社交值。</p><p>在时间复杂度上没有什么难点，只需要注意处理机制就行，因为这次作业的JML超长！！！！</p><h2 id="从规格到实现，性能如何保障？"><a href="#从规格到实现，性能如何保障？" class="headerlink" title="从规格到实现，性能如何保障？"></a>从规格到实现，性能如何保障？</h2><p>JML设计者在写规格时想的一定不是具体的实现方法，而是怎么去简单又完美的约束好一个接口的功能与副作用，是站在整体的角度思考问题的，想好了一切可能的行为，分别做好不同的约束处理。</p><p>实现则是在遵守JML约束的前提下，尽可能的提高实现的性能。此时工作人员想的是一个具体的实现方法。</p><h2 id="JUNIT测试"><a href="#JUNIT测试" class="headerlink" title="JUNIT测试"></a>JUNIT测试</h2><h3 id="一、JUnit-测试的本质与作用"><a href="#一、JUnit-测试的本质与作用" class="headerlink" title="一、JUnit 测试的本质与作用"></a>一、JUnit 测试的本质与作用</h3><p>JUnit 是 Java 中最常用的单元测试框架，主要用于：</p><ul><li><p>自动化验证类和方法的行为是否符合预期规格；</p></li><li><p>支持回归测试，及时发现代码修改带来的错误；</p></li><li><p>增强测试覆盖率（代码分支、边界、异常情况）；</p></li><li><p>与规格（如 JML）结合时，充当规格实现一致性的验证器。</p></li></ul><h3 id="二、利用“规格信息”设计-JUnit-测试的思路"><a href="#二、利用“规格信息”设计-JUnit-测试的思路" class="headerlink" title="二、利用“规格信息”设计 JUnit 测试的思路"></a>二、利用“规格信息”设计 JUnit 测试的思路</h3><ol><li>明确每个方法的规格（前置条件、后置条件、不变量）设计测试用例时：依据每条规格构造一个正例 + 至少一个反例。</li><li>将规格翻译为断言（assert）JUnit 提供 assertEquals, assertTrue, assertThrows 等断言方法。</li><li>结合边界值与等价类分析基于规格设计测试数据，覆盖各类输入场景。</li></ol><h3 id="三、JUnit-测试验证规格一致性的效果体现"><a href="#三、JUnit-测试验证规格一致性的效果体现" class="headerlink" title="三、JUnit 测试验证规格一致性的效果体现"></a>三、JUnit 测试验证规格一致性的效果体现</h3><ol><li>捕捉与规格不一致的实现错误如：</li></ol><ul><li><p>规格要求“相同关系不可重复添加”，但实现却允许重复；</p></li><li><p>JML 声明“添加后 size 增加”，但实际调用无变化。</p></li></ul><p>通过 JUnit 断言对比前后状态，可快速识别这些逻辑偏差。</p><ol start="2"><li><p>提高可维护性与回归保障一旦方法规格变更，只需更新对应测试：避免因手动测试遗漏导致旧功能失效；结合 CI&#x2F;CD，可以自动在提交时运行测试，保障规格长期一致性。</p></li><li><p>支持规格驱动开发（Test-first &#x2F; TDD）JUnit 测试与规格结合，可倒逼实现更加规范：先写规格 → 写测试用例 → 最后写实现，类似于“契约驱动开发”，提升代码清晰度与可预测性。</p></li></ol><h3 id="四、实际项目中的-JUnit-设计示例"><a href="#四、实际项目中的-JUnit-设计示例" class="headerlink" title="四、实际项目中的 JUnit 设计示例"></a>四、实际项目中的 JUnit 设计示例</h3><p>假设你有如下 JML 规格定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*@ requires id &gt; 0;<br>@ ensures \result != null;<br>@ ensures \result.getId() == id;<br>@*/<br>public Person getPerson(int id);<br></code></pre></td></tr></table></figure><p>可设计如下 JUnit 测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Test<br>public void testGetPersonNormal() &#123;<br>network.addPerson(1, &quot;Alice&quot;, 20);<br>Person p = network.getPerson(1);<br>assertNotNull(p);<br>assertEquals(1, p.getId());<br>&#125;<br><br>@Test<br>public void testGetPersonInvalidId() &#123;<br>assertThrows(IllegalArgumentException.class, () -&gt; network.getPerson(-1));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>本单元的学习让我真正体会到“规格先行”的重要性。JML 规格不仅仅是对接口行为的约束，更是一种程序设计的思维方式。它迫使我在写代码前先理清楚每一个函数的职责、边界与副作用，从而避免“边写边试、边改边错”的低效流程。</p><p>在实现过程中，面对复杂接口和状态维护时，我深刻认识到：良好的设计是性能和正确性的保障。比如在 Person 类中使用 TreeSet 优化最优好友查询、在 Tag 中用数学方法实现均值与方差的 O(1) 维护、以及在 Network 中用 BFS 替代复杂的连通性维护方案——这些都是在规格指引下不断优化的结果。</p><p>此外，借助大模型的协作能力，我从“提问者”成长为“任务设计者”。我学会了如何清晰地表达意图、分步拆解任务、构建提示模板，并通过反复调试与细节提问来获得更贴合需求的输出。这种交互方式不仅提升了效率，也让我意识到人工智能更像是一个“逻辑助理”，它不会替代你的判断，而是在你的设计之下发挥最大价值。</p><p>最后，JML + JUnit 的组合是一次理论与实践的双重磨砺。它让我意识到代码的正确性从来不是“写完跑一下就行”，而是一种自我约束、一种契约精神。测试不是验收，而是开发的一部分，它推动我不断思考：我的代码，是否真正做到了“言出法随”？</p><p>这个单元虽然挑战很多，但正因为如此，我收获的也更多。感谢助教提供的精细规格，感谢这次设计-实现-测试一体化的宝贵锻炼机会。</p>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit2</title>
      <link href="/2025/04/14/ooUnit2/"/>
      <url>/2025/04/14/ooUnit2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于面向对象多线程电梯那些事"><a href="#关于面向对象多线程电梯那些事" class="headerlink" title="关于面向对象多线程电梯那些事"></a>关于面向对象多线程电梯那些事</h1><p>写在前面：经历面向对象第二单元作业的这三周后，我对于多线程电梯的评价是很好的。这次作业给了我们机会去尝试多线程编程，能实际面临并解决多线程的资源竞争和线程安全问题。对我个人来说，我体会了多线程的复杂与神奇所在，在写每一个独立线程时需要时刻保持警惕，要把其它线程想象为一个陌生的程序员，保护自己的工作逻辑不受其它线程的破坏。</p><h2 id="Unit2三次作业感受"><a href="#Unit2三次作业感受" class="headerlink" title="Unit2三次作业感受"></a>Unit2三次作业感受</h2><p>个人感觉其实第一次作业是最难的，是因为第一次面临多线程设计是最不熟悉的，好在practice3给了我很大的启发和帮助。而第二次和第三次作业则相对简单了很多（不写影子电梯的话）。<br><img src="/../images/%E6%B5%81%E7%A8%8B.png" alt="流程"></p><h3 id="多线程协作与锁的选择"><a href="#多线程协作与锁的选择" class="headerlink" title="多线程协作与锁的选择"></a>多线程协作与锁的选择</h3><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p><img src="/../images/hw5.png" alt="hw5"><br>第一次作业需要设计三种线程，分别是InputHandler（输入处理），Dispatcher（请求分派）和elevator（电梯）；两类共享资源RequestTable（请求总表）和WaitTable（电梯等待队列）。这三种线程两种共享资源构成了两对生产者消费者模型。</p><p>InputHandler线程的逻辑非常简单，就是利用官方包从stdin读入数据并解析请求类型，第一次作业只有PersonRequest，所以InputHandler就只需考虑将请求信息封装为一个对象Person（方便后续电梯中途下人并重新分配电梯），然后作为生产者将Person投喂给RequestTable即可。</p><p>RequestTable作为共享资源，所要面临的是InputHandler的写入和Dispatcher的读出。对于InputHandler提供offer()方法，对Dispatcher提供poll()方法，同时设置一系列RequestTable的状态查询方法（如是否结束或者是否为空，以便所有请求都处理后线程都能正常结束）。荣老师在课上说对对象的方法上synchronized修饰上锁是不合适的，究其原因在于要最小化一个原子操作（待会解释什么是一个原子操作）。但是考虑到RequestTable方法本身非常简单，给方法修饰synchronized反而可能更安全。<br>对于共享资源的保护，我们提及了synchronized修饰符和原子操作这个概念，所谓原子操作，通俗一点的解释就是某一个线程的操作是不可被其它线程插入并修改共享资源从而改变运行逻辑的操作就是一个原子操作，就像原子是物质的基本组成粒子，不可再分（化学层面 :））。理解了原子性这个概念后，我们对于线程安全问题就能更上一层楼了。</p><p>Dispatcher设计或许在这一次作业里没那么重要，但是其存在为后续的非指派的分派算法设计提供了空间。当RequestTable非空时，Dispatcher从总表poll()一个请求，并按照设定的算法分派给对应电梯的WaitTable即可。为避免轮询白白占用cpu资源，我们需要让Dispatcher在RequestTable在为空但是未结束时“睡一会”，这里的“睡一会”并非真的睡觉（sleep），而是调用RequestTable.wait()进入RequestTable的等待队列。<br>这里又会涉及到一个新的概念：wait-notify。Dispatcher会先判断RequestTable的状态并决定是否进入RequestTable的等待队列，这里有两个点需要注意：</p><ol><li>Dispatcher需要分别查询RequestTable是否为空和是否结束，虽说是两次查询，但我们需要将这次行为作为一次原子操作，不然在第一次和第二次查询之间很有可能有其它线程抢走RequestTable的锁并改变了RequestTable的状态导致Dispatcher的逻辑错误。</li><li>为了避免死锁，我们需要在每一次改变共享对象的状态后调用notifyAll()将所有的处于共享对象的等待队列的线程唤醒，但是这个唤醒是无条件的，所以可能存在“假醒”的存在。所以我们需要将wait块包装在while(true)块内，唤醒后再一次查询资源状态，只有满足条件才会真的被唤醒。</li></ol><p>WaitTable同样作为共享资源，其所设计的逻辑和RequestTable是大差不差的，要为Dispatcher提供offer()方法，要为电梯提供poll()方法，内部维护的是分派给对应电梯的Person。</p><p>Elevator作为另一个消费者，其逻辑是根据WaitTable的状态和自身的决策算法，不断选择一定的运动，如移动，载人，放人，等待和结束。</p><p>第一次作业到此就结束了，虽然理清逻辑后觉得很简单，但是多线程编程设计时每写一句可能就需要考虑会不会造成线程冲突和不安全问题，会不会造成死锁问题。</p><h4 id="第二次作业与第三次作业"><a href="#第二次作业与第三次作业" class="headerlink" title="第二次作业与第三次作业"></a>第二次作业与第三次作业</h4><p><img src="/../images/hw6.png" alt="hw6"><br>第二次作业主要的改动有：</p><ol><li>不再提前指定请求分派的电梯，需要Dispatcher通过设计dispatch算法为请求分派请求。</li><li>新增SCHE特殊调度，并且这个调度的优先级很高，需要让电梯尽快的响应。</li></ol><p>这一次作业我觉得有几点设计是值得说一说的：</p><ol><li>将电梯属性和动作全部转至WaitTable维护，电梯本身抽象为一个纯粹的线程，只是不断的调用WaitTable的状态转移函数；电梯属性和电梯动作抽象为WaitTable的数据和属性改变和查询的方法。这么做虽然会大大增加WaitTable的复杂度，但是为外部设计带来了很多便利：<ul><li>Dispatcher设计dispatch算法时避免不了需要同时掌握等待队列和电梯的信息，然后决定分派给谁，当把电梯的属性转至WaitTable统一维护时，Dispatcher就只需要和WaitTable进行交互，同时也能提高电梯数性的安全性，避免了对于电梯属性的数据冲突。</li></ul></li><li>“围师必阙”：这一点设计我其实参考的是讨论区里助教的设计，注意到当电梯进入特殊调度状态时，就不能receive请求了，那如果某段时间只有一个电梯可用，同时这段时间来了大量的请求，如果分派算法设计的不好的话很有可能会把所有的请求都分派给“劳模电梯”，导致运行时间大大增加。那我们怎么解决这个问题呢，我们可以采用缓冲机制（Buffer），讨论区的助教可能是为了设计影子电梯分派算法而设计的这个机制，但是我发现其适用性非常广，于是便吸收进来化为己用。所谓缓冲机制，就是在WaitTable里设置另外一个容器，当Dispatcher决定将某一个请求分派给某一个电梯时，而此时电梯处于特殊调度状态，我们不直接把这个请求“分”给这个电梯，而是把这个请求放进这个特殊的容器，当电梯结束特殊调度状态时自动的把这个容器全部正式接收。</li><li>引入单例模式和多例模式。注意到在设计的过程中，经常需要访问其它对象，在这次作业里频次格外的高，但是把对象作为一个方法的参数传入的话实在不美观，于是我引入了单例模式和工厂模式。注意到RequestTable有且只有一个，电梯和与其对应的WaitTable存在6个。所以我把RequestTable设计为单例模式，把电梯和WaitTable设计为多例模式。其在程序创立之初就已经被静态的创建和存储在对应的Factory里，所以在需要访问某一个对象时就只需要向对应的静态Factory里请求即可。</li></ol><p>这里作业还有一个关于原子操作方面的点值得注意，与第一次作业不同的是，RequestTable还有可能会接受来自电梯的在分派请求，所以RequestTable是否结束的标准改为是否所有的请求都已经完成了，所以电梯在获得等待建议和执行wait进入WaitTable的等待队列的过程中需要保持为一个原子操作，否则，当最后一个电梯完成最后一个请求时，倘若Dispatcher线程插入，为WaitTable设为结束，但是当电梯重新拿回WaitTable的锁时，仍然会调用wait而不是结束线程，这时这个线程就会自此长睡不起了。</p><p><img src="/../images/hw7.png" alt="hw7"><br>第三次作业主要的改动有：</p><ol><li>新增双轿厢电梯，对应UPDATE请求。</li></ol><p>这次作业有两类设计是值得一说的：</p><ol><li>首先是线程同步机制，需要在UPDATE-begin和UPDATE-end进行两次同步，我采用了多例模式和CyclicBarrier结合的形式。我为每一对电梯都创建了实例化了一个CyclicBarrier，并存储在BarrierFactory里，在update的过程中，两个电梯通过同一个CyclicBarrier来进行同步。</li><li>关于双轿厢的设计，我自认为我的设计是比较简洁的。首先是结束UPDATE-end后，我不改变线程数量，仍然认为电梯处于自己的电梯井中，只是限制了其最高楼层和最低楼层，然后对于共享楼层的访问，设立了一个新的类SharedFloor，当电梯需要进入该楼层时，会向SharedFloor申请；当离开楼层时会“释放”该共享楼层的所有。同时要静止电梯在共享楼层等待从而长久的占用共享楼层。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class SharedFloor &#123;<br>    private boolean isOccupied = false;  // 标记是否被占用<br><br>    public synchronized void acquire() throws InterruptedException &#123;<br>        while (isOccupied) &#123;<br>            // 如果已被占用，线程进入等待状态<br>            wait();<br>        &#125;<br>        isOccupied = true;<br>    &#125;<br><br>    public synchronized void release() &#123;<br>        isOccupied = false;<br>        notifyAll(); // 唤醒所有等待的线程<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h3><h4 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h4><p>关于电梯的运作算法主要可能有ALS、SCAN、LOOK等，其实我个人在SCAN与LOOK中纠结了一下，但是鉴于往年学长统一的选择LOOK算法，我想这肯定是有道理的，便下定决心选择实现LOOK算法。</p><p>下面简单介绍一下LOOK算法：</p><ul><li>假定电梯处于某一层，且有一个特定的方向。</li><li>首先判断是否需要开门<ul><li>有人需要在该楼层下电梯</li><li>有人需要在该楼层进电梯</li></ul></li><li>然后判断电梯内部是否为空<ul><li>若不为空则往当前方向前进一步</li><li>再判断电梯是否有请求<ul><li>若电梯前方有请求则往当前运作方向前进一步</li><li>若电梯前方无请求则转向</li><li>若无请求则电梯进入睡眠状态</li></ul></li></ul></li></ul><p>所以getAdvice需要访问WaitTable维护的属性来确定电梯的下一步运作，所以在最外层套上对waitTable的synchronized块，实现代码大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Advice getAdvice() throws InterruptedException &#123;<br>        synchronized (this) &#123;<br>            if (sche != null) &#123;<br>                return Advice.SCHE;<br>            &#125;<br>            if (update != null) &#123;<br>                return Advice.UPDATE;<br>            &#125;<br><br>            if ((beRequested(floor, direction) &amp;&amp; inside.size() &lt; space) || canOut()) &#123;<br>                return Advice.OPEN;<br>            &#125; else if (!inside.isEmpty()) &#123;<br>                return Advice.MOVE;<br>            &#125; else &#123;<br>                if (isEmpty()) &#123;<br>                    if (isEnd()) &#123;<br>                        return Advice.END; //如果输入结束，电梯线程结束<br>                    &#125; else &#123;<br>                        if (sharing &amp;&amp; floor == transfer) &#123;<br>                            if (floor == top) &#123;<br>                                if (direction &gt; 0) &#123;<br>                                    return Advice.REVERSE;<br>                                &#125; else &#123;<br>                                    return Advice.MOVE;<br>                                &#125;<br>                            &#125; else if (floor == base) &#123;<br>                                if (direction &lt; 0) &#123;<br>                                    return Advice.REVERSE;<br>                                &#125; else &#123;<br>                                    return Advice.MOVE;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        this.wait();<br>                        return Advice.WAIT; //如果输入未结束，电梯线程等待<br>                    &#125;<br>                &#125; else &#123;<br>                    if (requestFront(floor, direction)) &#123;<br>                        return Advice.MOVE; //如果有请求发出地在电梯“前方”，则当前方向移动一层<br>                    &#125; else &#123;<br>                        return Advice.REVERSE; //电梯转向,不移动<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Dispatcher分派策略"><a href="#Dispatcher分派策略" class="headerlink" title="Dispatcher分派策略"></a>Dispatcher分派策略</h4><p>早已在刚进入计算机学院之处就听闻了影子电梯的大名，但是影子电梯需要同时获得六把锁，实现起来具有很大的风险，遂放弃，转而实现了随机分派策略。</p><p>随机分牌策略就是每一次分派时等可能的获得所想分派的电梯的id，然后仅需获得该电梯对应的WaitTable即可。但是在第二次和第三次作业中，电梯有可能处于特殊状态导致不能被分派，此时我们如果把所有请求分给空闲的电梯很有可能导致运行时间过长，为了解决这个问题让随机分派策略依然能进行下去，我设计了一种缓冲机制。</p><p>所谓缓冲机制，就是在电梯处于特殊状态时，不立即让这个电梯receive，而是存储在WaitTable的Buffer内，当电梯结束特殊状态后将Buffer清空并全部正式存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public synchronized void addBuffer(Person person) &#123;<br>     buffer.add(person);<br> &#125;<br> <br>synchronized (this) &#123;<br>        upDating = false;<br>        update = null;<br>        for (Person person : buffer) &#123;<br>            offer(person);<br>        &#125;<br>        buffer = new ArrayList&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DeBug方法"><a href="#DeBug方法" class="headerlink" title="DeBug方法"></a>DeBug方法</h2><h3 id="评测机的搭建"><a href="#评测机的搭建" class="headerlink" title="评测机的搭建"></a>评测机的搭建</h3><p>出于前几次作业没有做好评测而导致强测爆炸的惨痛经历，我在这单元充分的请教了D老师和G老师，将题目的指导书作为prompt，同时加入自己对于评测机的设计的思路，最终设计出了一个自动随机测试程序，遂用在了互测上，自动化评测房间里的同学，当出问题时就将对应的stdin和stdout信息保存下来，方便后续hack。</p><h3 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h3><p>光有评测机是远远不够的，处于多线程的随机性和无法调试性，我们很难直接从一般的输入输出信息发现自己程序的bug。受评论区大佬的启发，我单独开了一个DeBug类，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public class DeBug &#123;<br>    public static boolean d() &#123;<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在程序中每个关键节点输出日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (DeBug.d()) &#123;<br>     System.out.println(&quot;[Log] + 相关信息&quot;))<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察日志信息，就让我发现了我在上文提到的最后一个电梯无法结束的bug，我发现日志没有所有电梯的end信息，便迅速察觉到了这个bug并立即做了修复。</p><h2 id="日后谈"><a href="#日后谈" class="headerlink" title="日后谈"></a>日后谈</h2><p>在三次作业中，我逐渐加深了对线程安全的理解和实践：</p><ul><li>理解原子操作与synchronized的使用场景：起初通过简单地给方法加 synchronized 来实现互斥，后来意识到应该精细控制锁的粒度，只在必要的代码块加锁，避免造成性能浪费。</li><li>掌握了wait-notify机制：在生产者消费者模型中，用 wait() 和 notifyAll() 控制线程的唤醒与阻塞，尤其注意了在循环中使用 wait 防止“假唤醒”问题。</li><li>避免死锁与线程长时间阻塞：在设计过程中不断检查线程可能卡死的点，像是线程 wait 后永远不被唤醒、或者电梯“长睡不起”等，尽量做到每一个线程都能有序启动与结束。</li><li>共享资源访问保护：每次访问共享数据结构如请求队列、缓冲区等都考虑到了线程竞争，并通过锁机制保证数据一致性。</li></ul><p>随着作业难度的提升，我也逐步建立起了模块化和分层的编程习惯：</p><ul><li>将电梯与调度逻辑解耦：电梯线程只负责执行动作，调度决策交给外部管理，使逻辑更清晰，便于扩展。</li><li>引入工厂模式和单例模式：将一些全局对象（如请求表）做成单例，把多个电梯或资源用工厂统一管理，避免重复创建，提高代码可维护性。</li><li>采用缓冲机制与共享区抽象：例如在 UPDATE 和 SCHE 等特殊状态下加入缓冲队列，保证调度器分派灵活不冲突；设计 SharedFloor 类集中管理共享楼层的进入与退出，简化了双轿厢访问控制。</li><li>输出日志与自测工具：为每一个模块加上日志输出、设计评测机进行压力测试，帮助在复杂的多线程环境中快速定位问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ooUnit1</title>
      <link href="/2025/03/20/ooUnit1/"/>
      <url>/2025/03/20/ooUnit1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>oo第一单元的任务是表达式括号展开与化简，课程组的目的在于通过这一十分结构化的任务来把我们引入面向对象的设计思想，并设计了三次迭代作业开发，旨在模拟真实的作业环境。</p><p>这一个月以来，确实在oo这门课上吃了不少苦，但通过自己的努力从第一次作业进C组到第三次作业强测无bug，互测只有一个bug，也学到了一些东西。通过这篇博客，本人将对自己的这三次代码进行详细分析，并做一些总结。</p><h1 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h1><p>第一次作业是对单变量（x）的多项式的展开。</p><h2 id="UML类图与架构设计"><a href="#UML类图与架构设计" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>本次作业代码的UML图如下</p><p><img src="/../images/hw1.jpg" alt="hw1"></p><h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><h3 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h3><p>这部分内容比较简单，我们沿用pre中hw7递归下降的做法，首先将<code>Input</code>传给<code>Lexer</code>，在<code>Lexer</code>建立的过程中，就完成了对各种符号的特异提取以及对变量（这里只有<code>x</code>）和数字的识别，并存储为一个<code>Token</code>串。然后将建立好的<code>Lexer</code>传递给<code>parser</code>。</p><p>我们第一次听说递归下降的时候可能会感到有些陌生。递归下降，在这里就是通过层层递归调用来完成对字符串<code>Input</code>的结构化建树，代码逻辑和建树的过程一致，自顶向下的建立好每一个分支。</p><p>我们这里需要建立的就是一个<code>Expression</code>的树，根节点是一个<code>Expr</code>，它由若干个子节点<code>Term</code>相加表述而成。同理，<code>Term</code>由若干个<code>Factor</code>相乘表述而成，若<code>Factor</code>是<code>Num</code>或者<code>Var</code>则递归到了终点，若为<code>ExprFactor</code>(一种特殊的<code>Factor</code>,内容是一个<code>Expr</code>)则跳到对<code>Expr</code>的解析。</p><p>所以代码中递归下降的核心就在于<code>parser</code>的<code>parseExpr()</code>中。</p><p>调用这个函数后会返回一个建立好的<code>Expr</code>，并交给下一步处理。</p><h3 id="括号展开"><a href="#括号展开" class="headerlink" title="括号展开"></a>括号展开</h3><p>这部分是本次作业的难点，我们需要将表达式展开为如下形式：</p><p>$$ E &#x3D; \sum ax^i $$</p><p>我们不难发现，这种形式的最小单元是一个单项式，于是我们建立<code>MiniTerm</code>类来描述这个最小单元（事实上一开始的实现并不好，代码结构混乱，也导致了很多的bug，我将在后面重构整个代码结构，但是大致的思路没什么问题）。<br>我们在类内部实现MiniTerm的乘法和加法的化简，来实现对括号的展开，由于会重构的原因，代码展示会放在后面的部分。</p><h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><h3 id="表达式解析-1"><a href="#表达式解析-1" class="headerlink" title="表达式解析"></a>表达式解析</h3><p>本部分沿用了pre的代码，这里就不再展开了。</p><h3 id="括号展开-1"><a href="#括号展开-1" class="headerlink" title="括号展开"></a>括号展开</h3><h4 id="重构前"><a href="#重构前" class="headerlink" title="重构前"></a>重构前</h4><p>其实可以发现在重构前，可以发现我的代码有两个主要的问题：</p><ul><li>Expr、Term和Factor内部的属性其实并不是真正的private的，存在大量的get方法将他们暴露在外，也导致了我的不良的代码结构和很多的bug。</li><li>建类混乱，没有清晰的层次结构。</li></ul><p>如，我对于展开后的表达式的结构化没有表示的很好，只有一个简单的最小单元类，事实上应该有一个多项式类来管理多项式乘法，将其与单项式加法区分开。</p><h4 id="重构后"><a href="#重构后" class="headerlink" title="重构后"></a>重构后</h4><p>首先是我重构后的UNL类图：</p><p><img src="/../images/hw1_re.png" alt="hw1_re"></p><p>可以发现，我对于解析包做了保留，主要在化简包上做了工作。</p><p>首先，我建立了一个静态的类<code>Simplifier</code>，它内部的函数<code>simplifyExpr(Expr expr)</code>会将传进来的expr按层次解析：</p><pre><code>public static Poly simplifyExpr(Expr expresiton) &#123;    Poly result = new Poly();    for (int i = 0; i &lt; expresiton.amount(); i = i + 1) &#123;        Term term = expresiton.getTerm(i);        Poly termPoly = simplifyTerm(term);        result = Poly.addPoly(result, termPoly);    &#125;    return result;&#125;public static Poly simplifyTerm(Term term) &#123;    Poly result = new Poly();    for (int i = 0; i &lt; term.amount(); i = i + 1) &#123;        Factor factor = term.getFactor(i);        Poly factorPoly = simplifyFactor(factor);        result = Poly.multPoly(result, factorPoly);    &#125;    return result;&#125;public static Poly simplifyFactor(Factor factor) &#123;    return factor.toPoly();&#125;</code></pre><p>把解析的过程完全脱离于其他工作，代码结构清晰了不少。</p><p>我们可以发现在<code>simplifyFactor(Factor factor)</code>调用了<code>toPoly()</code>方法，这就要引入我们的Poly类了。<br>主要属性如下：</p><pre><code>private HashMap&lt;Unit, BigInteger&gt; units;private ArrayList&lt;Unit&gt; flag;</code></pre><p>其中units用来储存这次作业的最小单元：单项式和对于的幂；flag用来储存units中的Key，主要作用是在后期取值时保护属性不暴露在外，也方便索引unit。</p><p>然后我们在Poly中实现了对Unit的加法：</p><pre><code>public void addUnit(Unit m, BigInteger c) &#123;    Unit newM = m.check();    if (units.containsKey(newM)) &#123;        BigInteger coe = units.get(newM);        coe = coe.add(c);        if (coe.equals(BigInteger.ZERO)) &#123;            units.remove(newM);            flag.remove(newM);            if (!units.containsKey(Unit.ONE)) &#123;                units.put(Unit.ONE, BigInteger.ZERO);//保留常数项                flag.add(Unit.ONE);            &#125;        &#125;        units.replace(newM, coe);    &#125; else &#123;        units.put(newM, c);        flag.add(newM);    &#125;&#125;</code></pre><p>还实现了对Poly的乘法和加法：</p><pre><code>public static Poly multPoly(Poly poly1, Poly poly2) &#123;    if (poly1.amount() == 0) &#123;        return poly2;    &#125;    if (poly2.amount() == 0) &#123;        return poly1;    &#125;    Poly result = new Poly();    for (Unit unit1 : poly1.units.keySet()) &#123;        for (Unit unit2 : poly2.units.keySet()) &#123;            //...        &#125;    &#125;    return result;&#125;public static Poly addPoly(Poly poly1, Poly poly2) &#123;    Poly result = new Poly();    for (Unit unit : poly1.units.keySet()) &#123;        result.addUnit(unit, poly1.units.get(unit));    &#125;    for (Unit unit : poly2.units.keySet()) &#123;        result.addUnit(unit, poly2.units.get(unit));    &#125;    return result;&#125;</code></pre><p>在以上的运算中始终保持最终的返回结果是最简的。</p><p>这样之后，我们就可以在Factor中每一个类都写一个toPoly方法，并层层向上传递，当传到顶层的时候就构建好了我们所需要的没有括号的表达式结构了。</p><p>这次重构给我带来的感受很多，主要有以下几点：</p><ul><li>不要为了优化代码量和代码性能而丧失代码的结构性和可读性。</li><li>对于一个类的内容的处理要在对应的类中写一个方法来实现，并返回最终的结果。这样既减少了代码的耦合性，又增加了代码的可读性。</li></ul><h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><h2 id="UML类图与架构设计-1"><a href="#UML类图与架构设计-1" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>如下：</p><p><img src="/../images/hw2.png" alt="hw2"></p><h2 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>第二次作业新增的内容是括号嵌套、递归自定义函数和三角函数因子。</p><p>由于我在上一次作业已经实现了括号嵌套（ExprFactor递归到Expr）所以这次作业我将就三角函数因子和自定义递归函数的处理讲解。</p><h3 id="三角函数因子"><a href="#三角函数因子" class="headerlink" title="三角函数因子"></a>三角函数因子</h3><p>这部分内容比较简单，我们首先需要在Factor接口新增两个实现即可，分别是<code>SinFactor</code>和<code>CosFactor</code>，并实现其<code>toPoly()</code>方法。</p><p>其次需要改写<code>Unit</code>，新增如下属性</p><pre><code>private ArrayList&lt;Poly&gt; sinPolys;private HashMap&lt;Poly, BigInteger&gt; sinFactors;private ArrayList&lt;Poly&gt; cosPolys;private HashMap&lt;Poly, BigInteger&gt; cosFactors;</code></pre><p>并改写Poly和Unit的乘法加法逻辑即可，就可以完成三角函数因子这部分内容。</p><p>要注意的是三角函数因子内部存储的内容是因子。</p><h3 id="递归自定义函数"><a href="#递归自定义函数" class="headerlink" title="递归自定义函数"></a>递归自定义函数</h3><p>说实话，这部分内容花了我很大一部分心思，我初期苦恼于如何有效的存储自定义函数和调用自定义函数。</p><p>经过一天的思考后我的解决方案是沿用递归下降的思路遍历<code>Expr</code>树：</p><p>1.新建一个<code>Function</code>类，类内部的属性为：</p><pre><code>private final String name;//函数名private final ArrayList&lt;String&gt; paras;//形参列表private final BigInteger coeFunc1;//n-1项的系数private final ArrayList&lt;Expr&gt; paraFunc1; //n-1项的实参形式，用Expr储存private final BigInteger coeFunc2;//n-2项的系数private final ArrayList&lt;Expr&gt; paraFunc2; //n-2项的实参形式，用Expr储存private final Expr func0;//0项的形参表达式private final Expr func1;//1项的形参表达式private final Expr expression;//函数表达式</code></pre><p>2.新建一个静态<code>SolveFunc</code>类存储已经定义好的函数，用函数名索引<code>Function</code>存在HashMap中，处理传入的<code>Expr</code>，替换所有的<code>FuncFactor</code>后返回新的<code>Expr</code>。内部方法如下：</p><pre><code>public static Expr solveExpr(Expr expr) &#123;    Expr newExpr = new Expr();    for (int i = 0; i &lt; expr.amount(); i += 1) &#123;        Term term = expr.getTerm(i);        term = solveTerm(term);        newExpr.addTerm(term);    &#125;    return newExpr;&#125;public static Term solveTerm(Term term) &#123;    Term newTerm = new Term();    for (int i = 0; i &lt; term.amount(); i += 1) &#123;        Factor factor = term.getFactor(i);        newTerm.addFactor(solveFactor(factor));    &#125;    return newTerm;&#125;public static Factor solveFactor(Factor factor) &#123;    return factor.solveFunc();&#125;</code></pre><p>3.在所有<code>Factor</code>中实现对<code>FuncFactor</code>的处理，以实现替换书上的所有<code>FuncFactor</code>节点。</p><p>具体逻辑是遍历树上的每一个<code>Factor</code>节点，若遇上<code>FuncFactor</code>则调用<code>Function.call()</code>并传入该函数因子的信息，替换的逻辑中也沿用了<strong>递归下降</strong>的想法，先自顶向下构建好待替换的<code>Expr</code>(设计斐波那契递归,层层计算<code>n-1</code>项<code>Expr</code>和<code>n-2</code>项<code>Expr</code>然后相加返回到上一层)，然后包装成<code>ExprFactor</code>后放入<code>FuncFactor</code>的位置即可。<br>经过上述操作后，<code>Expr</code>没有了<code>FuncFactor</code>节点，传给<code>Simplifier</code>进行括号展开即可。</p><h2 id="Poly和Unit的新增内容"><a href="#Poly和Unit的新增内容" class="headerlink" title="Poly和Unit的新增内容"></a>Poly和Unit的新增内容</h2><p>本次作业的最小单元不再是 $ax^n$ 而是 $ ax^n\prod_{i}sin(Factor_i)\prod_{i}cos(Factor_i)$<br>所以我们只需要改写一下加法和乘法的逻辑保证依然在计算的过程中是最简的即可。</p><h1 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h1><h2 id="UML类图与架构设计-2"><a href="#UML类图与架构设计-2" class="headerlink" title="UML类图与架构设计"></a>UML类图与架构设计</h2><p>如下：</p><p><img src="/../images/hw3.png" alt="hw3"></p><h2 id="代码架构分析-1"><a href="#代码架构分析-1" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>可以发现，第三次作业的UML类图相比较于第二次作业的UML类图几乎没什么改动，一方面是因为这次作业的新增内容只有求导因子和自定义普通函数，另一方面是因为在第一次重构后我的代码的架构的优良。<br>由此也是第一次尝到了架构好的甜处。</p><h2 id="自定义普通函数"><a href="#自定义普通函数" class="headerlink" title="自定义普通函数"></a>自定义普通函数</h2><p>由于上一次作业已经实现了自定义递归函数，那我们也可以把自定义普通函数归于此，只需要把它看作递归深度为0的自定义递归函数即可，call时直接返回储存的0项表达式。</p><h2 id="求导因子"><a href="#求导因子" class="headerlink" title="求导因子"></a>求导因子</h2><p>第一步和第二次作业一样，先增加求导因子实现Factor这个接口。我们不难发现，实现求导的过程其实和替换FuncFactor的过程是可以很相似的，我们只需要一样的遍历整个树，当发现求导因子时，就递归的构建起表达式即可，这部分实现，我们放在了DerFactor里，代码结构如下：</p><pre><code>//SolveDer内容public static Expr solveExpr(Expr expr) &#123;    Expr newExpr = new Expr();    for (int i = 0; i &lt; expr.amount(); i += 1) &#123;        Term term = expr.getTerm(i);        term = solveTerm(term);        newExpr.addTerm(term);    &#125;    return newExpr;&#125;public static Term solveTerm(Term term) &#123;    Term newTerm = new Term();    for (int i = 0; i &lt; term.amount(); i += 1) &#123;        Factor factor = term.getFactor(i);        newTerm.addFactor(solveFactor(factor));    &#125;    return newTerm;&#125;public static Factor solveFactor(Factor factor) &#123;    return factor.solveDer();&#125;//DerFactor内容@Overridepublic Factor solveDer() &#123;    Expr newExpr = SolveDer.solveExpr(expr);//先解决expr的dx    newExpr = (Expr) newExpr.derive(); // expr.derive返回的是表达式    return new ExprFactor(newExpr, coe, exp);&#125;</code></pre><p>然后这次作业就很简单的被我们完成了。（好耶！！</p><h1 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h1><p>很不幸，本人在Unit1出现了许多的bug，让我们来一一分析一下bug的原因。</p><h2 id="HW1"><a href="#HW1" class="headerlink" title="HW1"></a>HW1</h2><p>在上文我们已经说过，第一作业的bug大多因为架构的不合理和代码风格的差劲。</p><p>那么不合理之处在哪呢？<br>1.类之间的耦合度高，没有做到把任务分解简化，而是让同一块处理多个混合的任务，非常容易导致bug。<br>下面就是hw1改写前的一些代码指标：</p><p><img src="/../images/hw1_%E6%8C%87%E6%A0%871%20.png" alt="指标1"></p><p>从左至右分别为OCavg Ocmax WMC</p><p><img src="/../images/hw1_%E6%8C%87%E6%A0%872.png" alt="指标2"></p><p>从左至右分别为Cogc ec(G) iv(G) v(G)</p><p>我们可以很明显的看出计算类和主类在多个指标中出现了不合理的数值，这明显是有缺陷的。</p><p>而在重构之后：</p><p><img src="/../images/hw1re.png" alt="hw1_re_指标"></p><p>计算类的指标好了许多，直观上我们也能感受到代码架构上的清晰化。</p><h2 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a>hw2</h2><p>第二次作业的bug主要是因为一处遗漏而导致的meg恶行bug，在强测多个点都出现了这个bug，在bug修复中修好后就大部分通过了。</p><p>另外一小部分是在优化中出了问题，这告诉我们优化需谨慎！！！</p><p>下面是hw2的一些指标</p><p><img src="/../images/hw2_%E6%8C%87%E6%A0%87.png" alt="hw2_指标"></p><p><img src="/../images/hw1re.png" alt="hw2_指标"></p><h2 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a>hw3</h2><p>第三次作业的bug是因为一处笔误导致的bug，这里就不展开描述了。</p><p><img src="/../images/hw2_%E6%8C%87%E6%A0%87.png" alt="hw3_指标"></p><p><img src="/../images/hw1re.png" alt="hw3_指标"></p><p><img src="/../images/hw3_%E6%8C%87%E6%A0%87.png" alt="hw3_指标"></p><h2 id="指标展现的优点"><a href="#指标展现的优点" class="headerlink" title="指标展现的优点"></a>指标展现的优点</h2><p>首先我的代码的耦合程度相较于我身边的同学是比较低的，我将各个任务分散到不同的模块中，从string到Expr的转换，处理FuncFactor，处理DerFactor，构建多项式并输出都是由独立的模块负责，并且将来如果有新的因子和处理，我还可以通过增添新的模块来完成这个任务，我的代码也因此可读性很高，也十分方便定位bug。</p><h2 id="指标展现的缺点"><a href="#指标展现的缺点" class="headerlink" title="指标展现的缺点"></a>指标展现的缺点</h2><p>但是由于上面不断的增添模块，如果需求越来越多，我的代码量也会越来越多，这将变得不利于维护。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本单元的优化我做的比较简单，主要集中在三角函数的合并优化。<br>首先是合并同类项，我重写了Expr、Term和Factor的HashCode和equals方法，这使得我判断两个Unit是否是同样的变得很简单，只需要调用containsKey()判断是否已经在Poly里即可。</p><p>但是这样还有一个问题，就是如果sin或者cos内的factor正好相差一个-1的系数呢？这个问题要完全解决比较苦难，所以我选择根据sin或cos里Poly的第一个Unit的符号做判断，如果是负号，那我选择将负号提到外面，这样一来即没有增添很多的代码，又能大大提高同类项的识别与合并概率。</p><h1 id="发现别人程序bug所采用的策略"><a href="#发现别人程序bug所采用的策略" class="headerlink" title="发现别人程序bug所采用的策略"></a>发现别人程序bug所采用的策略</h1><p>在经历hw2的惨痛教训后（没有好好评测自己的代码），我决定自己搭建一台评测机（主要是请教ChatGpt老师和DeepSeek老师）我让生成式人工智能为我写了一份评测数据的生成脚本，然后交给我自己写的自动化对拍程序，将互测小组内的成员的代码去跑我生成的评测数据并进行对拍，将不一致的结果记录下来，然后为了避免是同质的Bug，选择帮他们修复并重新评测。<br>这就是我这次hack采取的策略，但是不足的是，生成评测数据的脚本不是很强，并没有为我测处太多的bug，但好在为我自己的强测带来了很多好处。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ul><li><strong>写代码前先思考</strong> ： 如果啥都没想好就开写代码，那么这段代码一定会重构。</li><li><strong>多看学长学姐博客</strong> ： 学习前人经验和优秀的架构是一种好习惯，有时还能启发自己的新思路。</li><li><strong>注意代码的可读性和可拓展性</strong> ：千万不要为了代码量和编写方便而放弃代码的可读性，同时，这次Unit1的迭代开发经验还启示我一定要注意可拓展性。</li><li><strong>写代码时多关注代码指标</strong> ： 如果你发现自己的耦合度或者什么其他指标超标时，那么你就需要改一改你的架构了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2025/03/20/%E5%BC%80%E7%AF%87/"/>
      <url>/2025/03/20/%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="哇咔咔"><a href="#哇咔咔" class="headerlink" title="哇咔咔"></a>哇咔咔</h2><p><img src="/../images/%E9%94%A6%E9%B2%A4.jpg" alt="锦鲤"></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $^%@#!~ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单的自我介绍"><a href="#简单的自我介绍" class="headerlink" title="简单的自我介绍"></a>简单的自我介绍</h2><p>一个爱摸鱼但是也想发paper的北航计算机学生。</p><h2 id="为什么开这个博客"><a href="#为什么开这个博客" class="headerlink" title="为什么开这个博客"></a>为什么开这个博客</h2><p>想记录一下自己的生活（总不能让自己存在的唯一证明是留在沙发上的屁股印吧）</p><h2 id="我的联系方式"><a href="#我的联系方式" class="headerlink" title="我的联系方式"></a>我的联系方式</h2><ul><li>个人邮箱：<a href="mailto:&#74;&#99;&#x68;&#49;&#x38;&#50;&#57;&#55;&#52;&#57;&#x39;&#54;&#54;&#53;&#x40;&#x62;&#117;&#x61;&#97;&#x2e;&#x65;&#100;&#117;&#46;&#99;&#110;">&#74;&#99;&#x68;&#49;&#x38;&#50;&#57;&#55;&#52;&#57;&#x39;&#54;&#54;&#53;&#x40;&#x62;&#117;&#x61;&#97;&#x2e;&#x65;&#100;&#117;&#46;&#99;&#110;</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
