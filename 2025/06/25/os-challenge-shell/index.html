<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="Life, Code, Game">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/web-app-manifest-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/web-app-manifest-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/web-app-manifest-512x512.png">
    
    
    <link rel="mask-icon" href="/favicons/favicon.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="Game & Coding" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" aria-label=\"复制\"><i class=\"far fa-copy\"></i></button>",
              "</div>",
              "<div class=\"titlebar-center\">",
                "code",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" aria-label=\"复制\"><i class=\"far fa-copy\"></i></button>",
              "</div>",
              "<div class=\"titlebar-center\">",
                "code",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "<i class=\"far fa-check-square\"></i>";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "<i class=\"far fa-copy\"></i>";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>os_challenge_shell | Game & Coding - 随便写写</title>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">Game & Coding</a></h1>
        <h2 class="subtitle">随便写写</h2>
      </div>
      
      <div class="logo">
        <img src="/images/background2.jpg" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://JuChnaghao.github.io/2025/06/25/os-challenge-shell/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="Markus">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/selfish1.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="Game & Coding">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">os_challenge_shell</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2025-06-25T23:45:20+08:00">2025-06-25 23:45:20</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="lab6-challenge-shell"><a href="#lab6-challenge-shell" class="headerlink" title="lab6_challenge_shell"></a>lab6_challenge_shell</h1><p>我选择做相对有趣且有大量前人经验可参考的shell。</p>
<p>主要实现步骤有：</p>
<ul>
<li>语法分析</li>
<li>相对路径</li>
<li>拓展指令</li>
<li>环境变量</li>
<li>输入优化</li>
<li>历史指令</li>
<li>反引号、追加重定向与条件执行。</li>
</ul>
<p>总共6个部分内容，我将在下面一一展开描述我的实现。</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>因为mos的初始代码写的不是很好，在经过一段的时间的深思熟虑后，决定进行重构，搭建自己的语法树。由于这部分内容和oo的第一单元很类似，再加上ai的帮助，最后也没有花很长时间就完成了。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>首先是词法分析部分，类型申明如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 词法分析相关 */<br>typedef enum &#123;<br>    T_WORD, T_PIPE, T_SEMI, T_AND, T_OR,<br>    T_REDIR_IN, T_REDIR_OUT, T_REDIR_APP,<br>    T_BACKQUOTE_OPEN,T_BACKQUOTE_CLOSE,T_EOF<br>&#125; TokenType;<br><br>typedef struct &#123;<br>    TokenType type;<br>    char *value;<br>&#125; Token;<br><br>typedef struct &#123;<br>    char *input;<br>    size_t pos;<br>&#125; LexerState;<br><br>LexerState lexer;<br></code></pre></td></tr></table></figure>
<p>在shell中需要实现一行多指令、重定向、管道、条件执行和反引号，所以就先定义了WORD，PIPE,SEMI等Token种类，用以语法分析的时候区分不同的Token。</p>
<p>使用的时候先初始化lexer：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void init_lexer(const char *input) &#123;<br>	lexer.input = input;<br>	lexer.pos = 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在语法分析的时候每一次取一个Token出来分析：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 获取下一个 token，消费它；返回 Token 结构（value 若是 WORD 需 strdup，调用者负责 free）<br>void get_next_token(Token* t) &#123;<br>	while (strchr(WHITESPACE, *(lexer.input + lexer.pos))) &#123;<br>		lexer.pos ++ ;<br>	&#125; // 跳过空白符<br>	if (lexer.pos == strlen(lexer.input)) &#123;<br>		t-&gt;type = T_EOF;<br>		t-&gt;value = NULL;<br>		return;<br>	&#125; //读到EOF<br>	char c = lexer.input[lexer.pos];<br>	if (isWord(c)) &#123;<br>		char value[MAX_COMMAND_LEN];<br>		int len = handleLetter(value);<br>		t-&gt;type = T_WORD;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += len;<br>	&#125; else if (c == &#x27;&lt;&#x27;) &#123;<br>		char value[2];<br>		strcpy(value, &quot;&lt;&quot;);<br>		t-&gt;type = T_REDIR_IN;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += 1;<br>	&#125; else if (c == &#x27;&gt;&#x27;) &#123;<br>		char nc = lexer.input[lexer.pos + 1];<br>		if (nc == &#x27;&gt;&#x27;) &#123;<br>			char value[3];<br>			strcpy(value, &quot;&gt;&gt;&quot;);<br>			t-&gt;type = T_REDIR_APP;<br>			t-&gt;value = alloc_string(value);<br>			lexer.pos += 2;<br>		&#125; else &#123;<br>			char value[2];<br>			strcpy(value, &quot;&gt;&quot;);<br>			t-&gt;type = T_REDIR_OUT;<br>			t-&gt;value = alloc_string(value);<br>			lexer.pos += 1;<br>		&#125;<br>	&#125; else if (c == &#x27;|&#x27;) &#123;<br>		char nc = lexer.input[lexer.pos + 1];<br>		if (nc == &#x27;|&#x27;) &#123;<br>			char value[3];<br>			strcpy(value, &quot;||&quot;);<br>			t-&gt;type = T_OR;<br>			t-&gt;value = alloc_string(value);<br>			lexer.pos += 2;<br>		&#125; else &#123;<br>			char value[2];<br>			strcpy(value, &quot;|&quot;);<br>			t-&gt;type = T_PIPE;<br>			t-&gt;value = alloc_string(value);<br>			lexer.pos += 1;<br>		&#125;<br>	&#125; else if (c == &#x27;;&#x27;) &#123;<br>		char value[2];<br>		strcpy(value, &quot;;&quot;);<br>		t-&gt;type = T_SEMI;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += 1;<br>	&#125; else if (c == &#x27;&amp;&#x27;) &#123;<br>		char value[3];<br>		strcpy(value, &quot;&amp;&amp;&quot;);<br>		t-&gt;type = T_AND;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += 2;<br>	&#125; else if (c == &#x27;=&#x27;) &#123;<br>		char value[2];<br>		strcpy(value, &quot;=&quot;);<br>		t-&gt;type = T_WORD;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += 1;<br>	&#125; else if (c == &#x27;`&#x27;) &#123;<br>        char value[2];<br>		strcpy(value, &quot;`&quot;);<br>        if (backquote_num%2 == 0) &#123;<br>            t-&gt;type = T_BACKQUOTE_OPEN;<br>        &#125; else &#123;<br>            t-&gt;type = T_BACKQUOTE_CLOSE;<br>        &#125;<br>        backquote_num++;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += 1;<br>        //debugf(&quot;backquote!\n&quot;);<br>    &#125; else &#123;<br>		debugf(&quot;not defined token!: %c\n&quot;, c);<br>	&#125;<br><br>	return t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>词法分析的主要内容就是这些，主要是方便语法分析时把注意力放在Token上而不是字符上，这也是比较标准的做法。</p>
<h3 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析"></a>语法分析</h3><p>首先我们定义好要用的节点数据结构：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// === AST 结构及节点类型声明 ===<br><br>// AST 节点类型<br>typedef enum &#123;<br>    NODE_COMMAND,    // 基本命令<br>    NODE_REDIR_IN,   // 重定向 &lt;<br>    NODE_REDIR_OUT,  // 重定向 &gt;<br>    NODE_REDIR_APP,  // 重定向 &gt;&gt;<br>    NODE_PIPE,       // 管道 |<br>    NODE_AND,        // &amp;&amp;<br>    NODE_OR,         // ||<br>    NODE_SEQUENCE,   // 分号 ; （语句序列）<br>    NODE_BACKQUOTE,  // 反引号 `<br>    // 若将来支持后台 &#x27;&amp;&#x27;、子 Shell (…)、条件判断等，可继续扩展枚举<br>&#125; ASTNodeType;<br><br>// AST 节点结构<br>typedef struct ASTNode &#123;<br>    ASTNodeType type;<br>    union &#123;<br>        // 对于命令节点<br>        struct &#123;<br>            char *argv[MAXARGS];  // argv 数组，大小 argc+1，最后一个为 NULL<br>            int argc;<br>            struct ASTNode *backquote;<br>            int backquote_index;<br>        &#125; command;<br>        // 对于重定向节点（child 表示要重定向的命令或子结构）<br>        struct &#123;<br>            struct ASTNode *child;<br>            char *filename; // malloc 保存的文件名<br>            int mode;       // open() 时的 flags，如 O_RDONLY、O_WRONLY|O_CREAT|O_TRUNC、O_WRONLY|O_CREAT|O_APPEND<br>        &#125; redirect;<br>        // 对于二元操作：PIPE, AND, OR, SEQUENCE<br>        struct &#123;<br>            struct ASTNode *left;<br>            struct ASTNode *right;<br>        &#125; binary;<br>    &#125;;<br>&#125; ASTNode;<br></code></pre></td></tr></table></figure>

<p>可以看到同样定义了节点种类，不同的种类在union中取不同的元素，同时又保持了统一性，个人认为是一个比较优雅的实现。</p>
<p>我们先明确一下语法树会长什么样子，下面是语法：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 根据 EBNF:<br>// line     ::= list<br>// list     ::= and_or ( &quot;;&quot; and_or )*<br>// and_or   ::= pipeline ( ( &quot;&amp;&amp;&quot; | &quot;||&quot; ) pipeline )*<br>// pipeline ::= command ( &quot;|&quot; command )*<br>// command  ::= WORD ( WORD | redirect )*<br>// redirect ::= &quot;&lt;&quot; WORD | &quot;&gt;&quot; WORD | &quot;&gt;&gt;&quot; WORD<br></code></pre></td></tr></table></figure>
<p>一行指令由一个list组成；</p>
<p>一个list由若干and_or和<code>;</code>组成；</p>
<p>and_or由若干pipeline和<code>||</code>或者<code>&amp;&amp;</code>组成；</p>
<p>pipeline由若干command和<code>|</code>组成；</p>
<p>command里面又可能存在重定向符号然后command的参数可能存在反引号。</p>
<p>所以我们根据在树中的结构简单的将可能的节点种类划分为了三类，分别是重定向、指令和二元节点。</p>
<p>然后是parse指令部分，根据语法和上面划分好的结构，我们自定向下的建树，第一层是parse_list:</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Token current_token;<br><br>void next_token() &#123;<br>    get_next_token(&amp;current_token);<br>&#125;<br><br>ASTNode *parse_line() &#123;<br>    next_token();<br>    return parse_list();<br>&#125;<br><br>int accept_token(TokenType expect) &#123;<br>    if (current_token.type == expect) &#123;<br>        next_token();<br>        return 1;<br>    &#125;<br>    return 0;<br>&#125;<br><br>// 解析 list: 可能含分号<br>ASTNode *parse_list() &#123;<br>    ASTNode *left = parse_and_or();<br>    while (accept_token(T_SEMI)) &#123;<br>        ASTNode *right = parse_and_or();<br>        left = new_binary_node(NODE_SEQUENCE, left, right);<br>    &#125;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据分号的间隔解析成若干个and_or节点，并分别放到左节点和右节点。</p>
<p>比如：<code>ls;pwd;exit</code> 就解析成：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">      root<br>     /    \ <br>  binary  exit <br> /      \<br>ls      pwd<br></code></pre></td></tr></table></figure>

<p>分号的下一层是条件执行，由<code>||</code>和<code>&amp;&amp;</code>分隔。</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 解析 and_or：处理 &amp;&amp; 和 ||<br>ASTNode *parse_and_or() &#123;<br>    ASTNode *left = parse_pipeline();<br>    while (current_token.type == T_AND || current_token.type == T_OR) &#123;<br>        ASTNodeType op = (current_token.type == T_AND) ? NODE_AND : NODE_OR;<br>        next_token();<br>        ASTNode *right = parse_pipeline();<br>        left = new_binary_node(op, left, right);<br>    &#125;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>和分号都是binary节点，所以解析的步骤是一样的，只是分隔符不一样（while循环条件）。</p>
<p>条件执行的下一层是管道，和上面步骤也是一致的：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 解析 pipeline：处理管道 |<br>ASTNode *parse_pipeline() &#123;<br>    ASTNode *left = parse_command();<br>    while (accept_token(T_PIPE)) &#123;<br>        ASTNode *right = parse_command();<br>        left = new_binary_node(NODE_PIPE, left, right);<br>    &#125;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>管道下一层就是指令了，先看代码：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 解析单一 command（命令和其参数、重定向）<br>ASTNode *parse_command() &#123;<br>    if (current_token.type != T_WORD) &#123;<br>        debugf(&quot;UnExpected command : %d, value : %s\n&quot;, current_token.type, current_token.value);<br>    &#125;<br><br>    char *argv[MAXARGS]; // 固定最大参数数<br>    int argc = 0;<br>    ASTNode *backquote_ast = NULL;<br>    int backquote_index = -1;<br><br>    while (current_token.type == T_WORD || current_token.type == T_BACKQUOTE_OPEN) &#123;<br>        if (current_token.type == T_WORD) &#123;<br>            argv[argc++] = current_token.value;<br>            next_token();   <br>        &#125; else &#123;<br>            next_token();<br>            backquote_ast = parse_list();<br>            if (!accept_token(T_BACKQUOTE_CLOSE)) &#123;<br>                debugf(&quot;parse back quote wrong!\n&quot;);<br>                exit();<br>            &#125;<br>            backquote_index = argc;<br>            argc++;<br>        &#125;<br>    &#125;<br>    argv[argc] = NULL;<br><br>    ASTNode *node = new_command_node(argv, argc, backquote_ast, backquote_index);<br><br>    // 处理重定向<br>    while (current_token.type == T_REDIR_IN ||<br>           current_token.type == T_REDIR_OUT ||<br>           current_token.type == T_REDIR_APP) &#123;<br>        node = parse_redirect(node);<br>    &#125;<br><br>    return node;<br>&#125;<br><br>// 解析重定向，前提当前 token 是 &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&gt;&gt;&quot;<br>ASTNode *parse_redirect(ASTNode *prev_cmd_node) &#123;<br>    ASTNodeType rtype;<br>    int mode;<br>    if (accept_token(T_REDIR_IN)) &#123;<br>        rtype = NODE_REDIR_IN;<br>        mode = O_RDONLY;<br>    &#125; else if (accept_token(T_REDIR_OUT)) &#123;<br>        rtype = NODE_REDIR_OUT;<br>        mode = O_WRONLY | O_CREAT | O_TRUNC;<br>    &#125; else if (accept_token(T_REDIR_APP)) &#123;<br>        rtype = NODE_REDIR_APP;<br>        mode = O_WRONLY | O_CREAT | O_APPEND;<br>    &#125; else &#123;<br>        return prev_cmd_node; // 非重定向<br>    &#125;<br>    if (current_token.type != T_WORD) &#123;<br>        debugf(&quot;Expected filename after redirection\n&quot;);<br>    &#125;<br>    char *filename = current_token.value;<br>    next_token();<br>    return new_redirect_node(rtype, prev_cmd_node, filename, mode);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于command的解析，此时已经处于解析的最底层，所以通过是否是Word来取出对应的Token，然后放进argv数组里，若此时出现了反引号Backquote_OPEN，则重新进入parse list， 解析出一条完整的指令后标记好后续应该放入argv的index。</p>
<p>然后处理重定向部分，判断下一个Token是不是重定向符号，若是则进入parse_redirect部分。</p>
<p>就这样，通过递归下降法，我们一层一层的剥离了一行指令的结构，构造好了自己的语法树。</p>
<p>然后还有一个小技巧需要说明一下，由于mos没有实现动态内存分配，但是我们的树和字符串又需要动态申请，怎么办呢？</p>
<p>针对这个问题我使用的方法是现在sh.c里静态申请好一个长字符串和足够数量的AST树节点，然后写了对应的分配函数，当需要的时候就取出空闲的部分，不用的时候释放即可。下面是关键代码部分：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\======= 字符串申请==========\\<br>static char pool[STRING_POOL_SIZE];<br>static int used[STRING_POOL_SIZE];  // 标记每个字节是否被使用<br><br>void reset_string_pool() &#123;<br>    memset(pool, 0, sizeof(pool));<br>    memset(used, 0, sizeof(used));<br>&#125;<br><br>char *alloc_string(const char *src) &#123;<br>    int len = strlen(src) + 1;  // 包括 &#x27;\0&#x27;<br>    if (len &gt; STRING_MAX_LEN) return NULL;<br><br>    for (int i = 0; i &lt;= STRING_POOL_SIZE - len; ++i) &#123;<br>        int found = 1;<br>        for (int j = 0; j &lt; len; ++j) &#123;<br>            if (used[i + j]) &#123;<br>                found = 0;<br>                i += j;  // 跳过当前已使用区<br>                break;<br>            &#125;<br>        &#125;<br>        if (found) &#123;<br>            // 找到足够连续空间<br>            memcpy(&amp;pool[i], src, len);<br>            for (int j = 0; j &lt; len; ++j) &#123;<br>                used[i + j] = 1;<br>            &#125;<br>            return &amp;pool[i];<br>        &#125;<br>    &#125;<br><br>    return NULL;  // 空间不足<br>&#125;<br><br>\\========== AST 节点申请 ===========\\<br>static ASTNode nodes[MAX_NODES];<br>static uint8_t bitmap[MAX_NODES / 8];  // 1024 bits = 128 bytes<br><br>// 设置 bitmap 中的第 i 位为 1<br>void set_bit(int i) &#123;<br>    bitmap[i / 8] |= (1 &lt;&lt; (i % 8));<br>&#125;<br><br>// 设置 bitmap 中的第 i 位为 0<br>void clear_bit(int i) &#123;<br>    bitmap[i / 8] &amp;= ~(1 &lt;&lt; (i % 8));<br>&#125;<br><br>// 检查 bitmap 中的第 i 位是否为 1（已分配）<br>int is_allocated(int i) &#123;<br>    return (bitmap[i / 8] &gt;&gt; (i % 8)) &amp; 1;<br>&#125;<br><br>// 自定义 malloc: 分配一个空闲的 ASTNode<br>ASTNode* alloc_ast_node() &#123;<br>    for (int i = 0; i &lt; MAX_NODES; ++i) &#123;<br>        if (!is_allocated(i)) &#123;<br>            set_bit(i);<br>            return &amp;nodes[i];<br>        &#125;<br>    &#125;<br>    return NULL;  // 没有空闲节点<br>&#125;<br><br>// 自定义 free: 回收指定的 ASTNode<br>void free_ast_node(ASTNode* node) &#123;<br>    int index = node - nodes;<br>    if (index &gt;= 0 &amp;&amp; index &lt; MAX_NODES) &#123;<br>        clear_bit(index);<br>    &#125;<br>&#125;<br><br>// 释放 AST 节点（递归释放子节点、argv 中字符串等）<br>void free_ast(ASTNode *node) &#123;<br>    if (!node) return;<br><br>    switch (node-&gt;type) &#123;<br>        case NODE_COMMAND:<br>            // 不释放 argv[i] 或 argv，只释放节点<br>            break;<br><br>        case NODE_REDIR_IN:<br>        case NODE_REDIR_OUT:<br>        case NODE_REDIR_APP:<br>            free_ast(node-&gt;redirect.child); // 递归释放子节点<br>            break;<br><br>        case NODE_PIPE:<br>        case NODE_AND:<br>        case NODE_OR:<br>        case NODE_SEQUENCE:<br>            free_ast(node-&gt;binary.left);<br>            free_ast(node-&gt;binary.right);<br>            break;<br><br>        default:<br>            break;<br>    &#125;<br><br>    // 释放当前节点到池中<br>    free_ast_node(node);<br>&#125;<br><br>ASTNode *new_command_node(char **argv, int argc, ASTNode* backquote, int backquote_index) &#123;<br>    ASTNode *node = alloc_ast_node();<br>    node-&gt;type = NODE_COMMAND;<br>	int i;<br>    for(i = 0; argv[i] != NULL; i++) &#123;<br>		node-&gt;command.argv[i] = argv[i];<br>	&#125;<br>	node-&gt;command.argv[i] = NULL;<br>    node-&gt;command.argc = argc;<br>    node-&gt;command.backquote = backquote;<br>    node-&gt;command.backquote_index = backquote_index;<br>    return node;<br>&#125;<br><br>ASTNode *new_redirect_node(ASTNodeType type, ASTNode *child, char *filename, int mode) &#123;<br>    ASTNode *node = alloc_ast_node();<br>    node-&gt;type = type;<br>    node-&gt;redirect.child = child;<br>    node-&gt;redirect.filename = filename;<br>    node-&gt;redirect.mode = mode;<br>    return node;<br>&#125;<br><br>ASTNode *new_binary_node(ASTNodeType type, ASTNode *left, ASTNode *right) &#123;<br>    ASTNode *node = alloc_ast_node();<br>    node-&gt;type = type;<br>    node-&gt;binary.left = left;<br>    node-&gt;binary.right = right;<br>    return node;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出我用的是位图法进行的空闲部分的管理，在申请的时候置位位图，在释放的时候置零位图即可。</p>
<h3 id="语法树执行"><a href="#语法树执行" class="headerlink" title="语法树执行"></a>语法树执行</h3><p>经过上面的折腾，我们已经按执行优先级解析完了我们指令的结构，下一步就是执行了，我们用深度优先搜索的方法对整棵树进行遍历即可，下面是关键代码：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 执行 AST，返回子命令退出状态或整体状态<br>int execute_ast(ASTNode *node, int in_subshell) &#123;<br>    if (!node) return 0;<br>    switch (node-&gt;type) &#123;<br>        case NODE_COMMAND:<br>            return exec_command_node(node, in_subshell);<br>        case NODE_PIPE:<br>            return exec_pipe_node(node, in_subshell);<br>        case NODE_AND:<br>            return exec_and_node(node, in_subshell);<br>        case NODE_OR:<br>            return exec_or_node(node, in_subshell);<br>        case NODE_SEQUENCE:<br>            return exec_sequence_node(node, in_subshell);<br>        case NODE_REDIR_IN:<br>        case NODE_REDIR_OUT:<br>        case NODE_REDIR_APP:<br>            return exec_redirection_node(node, in_subshell);<br>        default:<br>            debugf(&quot;Unsupported AST node type %d\n&quot;, node-&gt;type);<br>            return 1;<br>    &#125;<br>&#125;<br>//分派函数<br>int exec_command_node(ASTNode *node, int in_subshell) &#123;<br>    char **argv = node-&gt;command.argv;<br>    if (argv[0] == NULL) return 0;<br>    //处理反引号<br>    handleBackquote(node);<br>	//处理变量<br>	for (int i = 0; argv[i] != NULL; i++) &#123;<br>    	replace_vars(argv[i]);<br>		if (strlen(argv[i]) == 0) &#123;<br>			for(int j = i; argv[j] != NULL; j++) &#123;<br>				argv[j] = argv[j+1];<br>			&#125;<br>			i-=1;<br>		&#125;<br>	&#125;<br>    if (is_builtin(argv[0])) &#123;<br>        return run_builtin(argv);<br>    &#125; else &#123;<br>        int child = spawn(argv[0], argv);<br>		if (child &gt;= 0) &#123;<br>			wait(child);<br>		&#125; else &#123;<br>			debugf(&quot;spawn %s: %d\n&quot;, argv[0], child);<br>		&#125;<br>        int r = syscall_get_last_call();<br>        return r;<br>	&#125;<br><br>	return 0;<br>&#125;<br><br>int exec_pipe_node(ASTNode *node, int in_subshell) &#123;<br>    int fds[2];<br>	int r;<br>    if (r = pipe(fds) &lt; 0) &#123;<br>        user_panic(&quot;pipe : %d&quot;, r);<br>    &#125;<br>    int pid_left = fork();<br>    if (pid_left &lt; 0) &#123;<br>        user_panic(&quot;fork : %d&quot;, pid_left);<br>        close(fds[0]); <br>		close(fds[1]);<br>        return 1;<br>    &#125;<br>    if (pid_left == 0) &#123;<br>        // 左侧子进程<br>        close(fds[0]);<br>        if (dup(fds[1], STDOUT_FILENO) &lt; 0) &#123;<br>            user_panic(&quot;dup&quot;); <br>			exit();<br>        &#125;<br>        close(fds[1]);<br>        // 在子进程中执行左子 AST<br>        execute_ast(node-&gt;binary.left, 1);<br>        exit();<br>    &#125;<br>    int pid_right = fork();<br>    int result = 0;<br>    if (pid_right &lt; 0) &#123;<br>        user_panic(&quot;fork&quot;);<br>        // 关闭并等待左<br>        close(fds[0]); <br>		close(fds[1]);<br>        wait(pid_left);<br>        return 1;<br>    &#125;<br>    if (pid_right == 0) &#123;<br>        // 右侧子进程<br>        close(fds[1]);<br>        if (dup(fds[0], STDIN_FILENO) &lt; 0) &#123;<br>            user_panic(&quot;dup&quot;);<br>			exit();<br>        &#125;<br>        close(fds[0]);<br>        int result = execute_ast(node-&gt;binary.right, 1);<br>        exit();<br>    &#125;<br>    // 父进程<br>    close(fds[0]); <br>	close(fds[1]);<br>    wait(pid_left);<br>	wait(pid_right);<br>    <br>    return result;<br>&#125;<br><br>int exec_sequence_node(ASTNode *node, int in_subshell) &#123;<br>    // 左侧执行，忽略或记录状态<br>    execute_ast(node-&gt;binary.left, in_subshell);<br>    return execute_ast(node-&gt;binary.right, in_subshell);<br>&#125;<br><br>int exec_redirection_node(ASTNode *node, int in_subshell) &#123;<br>    int fd;<br>    handleBackquote(node-&gt;redirect.child);<br>    if (node-&gt;type == NODE_REDIR_IN) &#123;<br>        fd = open(node-&gt;redirect.filename, O_RDONLY);<br>        if (fd &lt; 0) &#123; <br>			debugf(&quot;failed to open : %s\n&quot;, node-&gt;redirect.filename); <br>			return 1; <br>		&#125;<br>        if (dup(fd, STDIN_FILENO) &lt; 0) &#123; <br>			debugf(&quot;dup error\n&quot;); <br>			close(fd); <br>			return 1; <br>		&#125;<br>        close(fd);<br>    &#125; else if (node-&gt;type == NODE_REDIR_OUT) &#123;<br>        fd = open(node-&gt;redirect.filename, O_WRONLY | O_CREAT | O_TRUNC);<br>        if (fd &lt; 0) &#123; <br>			debugf(&quot;open wrong : %s\n&quot;, node-&gt;redirect.filename); <br>			return 1; <br>		&#125;<br>        if (dup(fd, STDOUT_FILENO) &lt; 0) &#123; <br>			debugf(&quot;dup error&quot;); <br>			close(fd); <br>            return 1; <br>		&#125;<br>        close(fd);<br>    &#125; else if (node-&gt;type == NODE_REDIR_APP) &#123;<br>        fd = open(node-&gt;redirect.filename, O_WRONLY | O_CREAT | O_APPEND);<br>        if (fd &lt; 0) &#123; <br>			debugf(&quot;open wrong : %s\n&quot;, node-&gt;redirect.filename); <br>			return 1; <br>		&#125;<br>        if (dup(fd, STDOUT_FILENO) &lt; 0) &#123; <br>			debugf(&quot;dup eooro\n&quot;); <br>			close(fd); <br>			return 1; <br>		&#125;<br>        close(fd);<br>    &#125; else &#123;<br>        // 不应到达<br>        debugf(&quot;Unknown redirection type %d\n&quot;, node-&gt;type);<br>        return 1;<br>    &#125;<br>    // 设置完成后执行子节点<br>    return execute_ast(node-&gt;redirect.child, in_subshell);<br>&#125;<br><br>int exec_and_node(ASTNode *node, int in_subshell) &#123;<br>    int status = execute_ast(node-&gt;binary.left, in_subshell);<br>    if (status == 0) &#123;<br>        return execute_ast(node-&gt;binary.right, in_subshell);<br>    &#125;<br>    return status;<br>&#125;<br><br>int exec_or_node(ASTNode *node, int in_subshell) &#123;<br>    int status = execute_ast(node-&gt;binary.left, in_subshell);<br>    if (status != 0) &#123;<br>        return execute_ast(node-&gt;binary.right, in_subshell);<br>    &#125;<br>    return status;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于任意一个节点AST我们都按照统一的流程进行处理，首先由execute_ast判断当前节点类型进行分派。</p>
<p>如果是sequence_node（分号），先执行左子节点后执行右子节点，实现一行多指令效果，同时左侧指令先于右侧指令执行。</p>
<p>如果是and_node或者or_node（条件执行），先执行左子节点，同时获取左子节点的返回值，再以此判断是否执行右子节点，如何获取返回值在后续会具体展开回答。</p>
<p>如果是pipe_node（管道），开两个子进程，并将标准输入输出重定向到管道实现参数传递，由于在子进程执行，所以不影响shell进程的标准输入输出。</p>
<p>如果是redirection_node（重定向），先打开对应文件，并根据重定向类型选择标准输入或者输出重定向到对应文件描述符，然后执行指令即可。</p>
<p>如果是command_node（指令），则判断是内建指令还是外部指令，内建指令进入run_builtin,外部指令按lab6流程来，如下图：</p>
<p><img src="/../images/spawn.png" alt="img.png"></p>
<p>进入spawn函数处理流程。</p>
<p>至此我们就完整的重构好了lab6的指令分析和执行部分的内容，这位我们后面的工作带来了很大的便利，事实上，我们在重构的过程中已经实现很多指令优化部分的内容了，这就是语法树的强大所在。</p>
<p>让我们进入真正的shell拓展内容：</p>
<h2 id="相对路径支持"><a href="#相对路径支持" class="headerlink" title="相对路径支持"></a>相对路径支持</h2><h3 id="open-remove"><a href="#open-remove" class="headerlink" title="open remove"></a>open remove</h3><p>在原始的mos里只支持绝对路径，所以要想支持相对路径最简单快捷的办法就是更改文件系统里的代码。</p>
<p>我们只需要在文件open、remove的时候将rq-&gt;path改为绝对路径即可，关键代码如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\user/lib/file.c open<br>	if (has_relative_component(path)) &#123;<br>		strcpy(buf, path);<br>		normalize_path_inplace1(curwd, buf);<br>		path = buf;<br>		//debugf(&quot;normalize path: %s\n&quot;, path);<br>	&#125; else if (path[0] != &#x27;/&#x27;)&#123;<br>		if (!str_eq1(curwd, &quot;/&quot;)) &#123;<br>			strcpy(curwd + strlen(curwd), &quot;/&quot;);<br>		&#125;<br>		strcpy(curwd + strlen(curwd), path);<br>		path = curwd;<br>		//debugf(&quot;cat path: %s\n&quot;, path);<br>	&#125;<br>\\user/lib/file.c remove<br>    char curwd[1024];<br>	syscall_get_cwd(curwd);<br>	char buf[1024];<br>	strcpy(buf, path);<br>	normalize_path_inplace1(curwd, buf);<br>	path = buf;<br></code></pre></td></tr></table></figure>
<p>其中normalize_path_inplace1是将buf依据当前工作路径进行拓展，这样就能支持参数里的相对路径了。</p>
<h3 id="cd、pwd和当前工作目录"><a href="#cd、pwd和当前工作目录" class="headerlink" title="cd、pwd和当前工作目录"></a>cd、pwd和当前工作目录</h3><p>下一步我们需要实现两个内建指令cd和pwd</p>
<p>cd指令的实现本次挑战性任务最难的部分，因为cd需要更改当前shell的工作目录，而这部分与进程强相关，在mos中是先fork一个子进程然后再执行run_cmd的，因为这样的操作可以避免一些恶意的操作直接导致shell本身被破坏，比如标准输入输出被修改了等等。</p>
<p>但是这也给我们实现cd带来一个难题，那就是我们如何保证cd能让shell的进程的工作目录被修改呢？</p>
<p>经过长时间的思考和讨论，我和室友最终采取了一个算是比较轻便的方法，但是不够优雅，对于这次挑战性任务却足够了。</p>
<p>首先，我们在进程控制块Env中添加一个char cwd[1024]的工作路径属性，用来标记当前shell的工作目录。</p>
<p>进程创建时，子进程继承父进程的工作目录，若是第一个被创建的进程，cwd被初始化为根目录<code>/</code>。</p>
<p>然后实现两个系统调用syscall_get_cwd()和syscall_change_cwd(char* path),其中关键的是syscall_change_cwd的实现，在该函数的内核态部分，我们取出当前进程curenv的父进程，并将其父进程的cwd修改为cd的路径，因为cd一定是在runcmd进程或者其子进程中执行的，并且若是在其子进程中执行则不影响shell的工作目录，这一点和bash的行为一致，所以我们只需要修改父进程的cwd即可，而不需要在意更深层的影响。</p>
<p>关键代码如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\内核态部分<br>void sys_change_cwd(char* s) &#123;<br>	struct Env* parent_env;<br>	envid2env(curenv-&gt;env_parent_id, &amp;parent_env, 0);<br>	strcpy(curenv-&gt;cwd, s);<br>	strcpy(parent_env-&gt;cwd, s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在cd之前，我们对于路径的合法性也需要检验，并判断是否是目录，同时也需要支持相对路径（和上面一样）</p>
<p>然后对于pwd的实现就很简单了，只需要取出当前进程的cwd然后输出即可。</p>
<h2 id="拓展指令"><a href="#拓展指令" class="headerlink" title="拓展指令"></a>拓展指令</h2><p>这部分我们需要实现 mkdir， rm， touch 和exit。</p>
<p>对于前三个指令，我主要参考了zyt学长的代码，在此感谢zyt学长！！！(<a target="_blank" rel="noopener" href="https://github.com/zhangyitonggg/BUAA-OS-challenge">学长的代码</a>)</p>
<p>同时为了方便实现条件执行，我做了相应的返回值修改</p>
<p>以下是关键代码：</p>
<p>mkdir:</p>
<p>实现思路分-p和无-p两部分，有-p则忽视父目录不存在的情况，若不存在则创建。</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;lib.h&gt;<br><br>int flag;<br><br>int mkdir(char *path) &#123;<br>    int fd;<br>    int result = 0;<br>    if (flag) &#123;<br>        if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>            close(fd);<br>            return;<br>        &#125;<br>        int i = 0;<br>        char str[1024];<br>        for (int i = 0; path[i] != &#x27;\0&#x27;; ++i) &#123;<br>            if (path[i] == &#x27;/&#x27;) &#123;<br>                str[i] = &#x27;\0&#x27;;<br>                if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>                    close(fd);<br>                &#125; else &#123;<br>                    break;<br>                &#125; <br>            &#125;<br>            str[i] = path[i];<br>        &#125;<br>        for (; path[i] != &#x27;\0&#x27;; ++i) &#123;<br>            if (path[i] == &#x27;/&#x27;) &#123;<br>                str[i] = &#x27;\0&#x27;;<br>                //debugf(&quot;path : %s\n&quot;, str);<br>                fd = open(str, O_RDONLY);<br>                if (fd &gt;= 0) &#123;<br>                    close(fd);<br>                &#125; else &#123;<br>                    fd = open(str, O_MKDIR);<br>                    if (fd &gt;= 0) &#123;<br>                        close(fd);<br>                    &#125; else &#123;<br>                        debugf(&quot;error when mkdir\n&quot;);<br>                        result = 1;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            str[i] = path[i];<br>        &#125;<br>        str[i] = &#x27;\0&#x27;;<br>        fd = open(str, O_MKDIR);<br>        if (fd &gt;= 0) &#123;<br>            close(fd);<br>        &#125; else &#123;<br>            printf(&quot;other error when mkdir %s, error code is %d\n&quot;, path, fd);<br>            result = 1;<br>        &#125;<br>    &#125; else &#123;<br>        if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>            close(fd);<br>            printf(&quot;mkdir: cannot create directory &#x27;%s&#x27;: File exists\n&quot;, path);<br>            result = 1;<br>            return;<br>        &#125;<br>        fd = open(path, O_MKDIR);<br>        if (fd == -10) &#123;<br>            printf(&quot;mkdir: cannot create directory &#x27;%s&#x27;: No such file or directory\n&quot;, path);<br>            result = 1;<br>        &#125; else if (fd &lt; 0) &#123;<br>            printf(&quot;other error when mkdir %s, error code is %d\n&quot;, path, fd);<br>            result = 1;<br>        &#125; else &#123;<br>            close(fd);<br>        &#125;<br>    &#125;<br>    return result;<br>&#125;<br><br>int main(int argc, char **argv) &#123;<br>    char s[5] = &quot;-p&quot;;<br>    int result = 0;<br>    for (int i = 1; i &lt; argc; i++) &#123;<br>        if (strcmp(argv[i], s) == 0) &#123;<br>            argv[i] = 0;<br>            flag = 1;<br>            break;<br>        &#125;<br>    &#125;    <br><br>    if (argc &lt; 2) &#123;<br>        user_panic(&quot;nothing to mkdir\n&quot;);<br>    &#125; else &#123;<br>        for (int i = 1; i &lt; argc; ++i) &#123;<br>            if (argv[i] == 0) &#123;<br>                continue;<br>            &#125;<br>            int r = mkdir(argv[i]);<br>            if (r != 0) &#123;<br>                result = 1;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>rm:</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;lib.h&gt;<br><br>int flag_r;<br>int flag_f;<br><br>int rm(char *path) &#123;<br>    int fd;<br>    struct Stat st;<br>    if ((fd = open(path, O_RDONLY)) &lt; 0) &#123;<br>        if (!flag_f) &#123;<br>            printf(&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;, path);<br>        &#125;<br>        return 1;<br>    &#125;<br>    close(fd);<br>    stat(path, &amp;st);<br>    if (st.st_isdir &amp;&amp; !flag_r) &#123;<br>        printf(&quot;rm: cannot remove &#x27;%s&#x27;: Is a directory\n&quot;, path);<br>        return 1;<br>    &#125;<br>    remove(path);<br>    <br>    return 0;<br>&#125;<br><br>int main(int argc, char **argv) &#123;<br>    char s_r[5] = &quot;-r&quot;;<br>    char s_rf[5] = &quot;-rf&quot;;<br>    int result = 0;<br>    for (int i = 1; i &lt; argc; i++) &#123;<br>        if (strcmp(argv[i], s_r) == 0) &#123;<br>            argv[i] = 0;<br>            flag_r = 1;<br>        &#125; else if (strcmp(argv[i], s_rf) == 0) &#123;<br>            argv[i] = 0;<br>            flag_f = 1;<br>            flag_r = 1;<br>        &#125;<br>    &#125;<br><br>    if (argc &lt; 2) &#123;<br>        printf(&quot;nothing to rm\n&quot;);<br>    &#125; else &#123;<br>        for (int i = 1; i &lt; argc; ++i) &#123;<br>            if (argv[i] == 0) &#123;<br>                continue;<br>            &#125;<br>            int r = rm(argv[i]);<br>            if (r != 0) &#123;<br>                result = 1;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>touch:<br>实现思路就是先判断文件和父目录是否存在，若父目录不存在则抛出错误，并返回非0值，若文件不存在则创建一个新的文件。</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;lib.h&gt;<br><br>int touch(char *path) &#123;<br>    int fd;<br>    int flag = 0;<br>    if ((fd = open(path, O_RDONLY)) &gt;= 0) &#123;<br>        close(fd);<br>        return;<br>    &#125;<br>    fd = open(path, O_CREAT);<br>    if (fd == -10) &#123;<br>        printf(&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;, path);<br>        flag = 1;<br>    &#125; else if (fd &lt; 0) &#123;<br>        printf(&quot;other error when touch %s, error code is %d\n&quot;, path, fd);<br>        flag = 1;<br>    &#125; else &#123;<br>        close(fd);<br>    &#125;<br>    return flag;<br>&#125;<br><br>int main(int argc, char **argv) &#123;<br>    int flag = 0;<br>    if (argc &lt; 2) &#123;<br>        printf(&quot;nothing to touch\n&quot;);<br>    &#125; else &#123;<br>        for (int i = 1; i &lt; argc; ++i) &#123;<br>            int r = touch(argv[i]);<br>            if (r != 0) &#123;<br>                flag = 1;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return flag;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>exit:</p>
<p>这个指令则是每次readline后特判是不是exit，若是的话则直接执行<code>exit()</code>即可。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>熟悉了工作目录更改的那一套系统调用流程后，这一部分就好多了，我们继续利用万能的进程控制块和系统调用来实现这这一部分内容。</p>
<p>首先我们在进程控制块里增添新的内容：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct variable &#123;<br>	char key[17];<br>	char value[17];<br>	int mode; //0为全局， 1为局部<br>	int perm; //0为可读可写， 1为只读<br>&#125;;<br><br>// Control block of an environment (process).<br>struct Env &#123;<br>	struct Trapframe env_tf;	 // saved context (registers) before switching<br>	LIST_ENTRY(Env) env_link;	 // intrusive entry in &#x27;env_free_list&#x27;<br>	u_int env_id;			 // unique environment identifier<br>	u_int env_asid;			 // ASID of this env<br>	u_int env_parent_id;		 // env_id of this env&#x27;s parent<br>	u_int env_status;		 // status of this env<br>	Pde *env_pgdir;			 // page directory<br>	TAILQ_ENTRY(Env) env_sched_link; // intrusive entry in &#x27;env_sched_list&#x27;<br>	u_int env_pri;			 // schedule priority<br><br>	// Lab 4 IPC<br>	u_int env_ipc_value;   // the value sent to us<br>	u_int env_ipc_from;    // envid of the sender<br>	u_int env_ipc_recving; // whether this env is blocked receiving<br>	u_int env_ipc_dstva;   // va at which the received page should be mapped<br>	u_int env_ipc_perm;    // perm in which the received page should be mapped<br><br>	// Lab 4 fault handling<br>	u_int env_user_tlb_mod_entry; // userspace TLB Mod handler<br><br>	// Lab 6 scheduler counts<br>	u_int env_runs; // number of times we&#x27;ve been env_run&#x27;ed<br><br>	// lab 6_shell<br>	char cwd[1024];<br>	struct variable var[32];<br>	int var_num;<br>	int last_call;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后继续按cd那一套来，增添4个系统调用，分别用来设置环境变量，取消环境变量，查询环境变量以及打印环境变量。</p>
<p>同理，这四个系统调用也是针对的父进程的环境控制块进行的操作。</p>
<h2 id="输入优化"><a href="#输入优化" class="headerlink" title="输入优化"></a>输入优化</h2><h3 id="指令自由输入"><a href="#指令自由输入" class="headerlink" title="指令自由输入"></a>指令自由输入</h3><p>这一部分我们修改readline的内容，保证readline能处理左右方向键和Backspace.</p>
<p>先设置好当前输入长度和光标位置变量。</p>
<p>识别当前字符是左右键时就移动光标到相应位置，相对对应的，输入字符时就让光标右边的字符整体右移一格，然后在光标处设置为当前字符，然后光标自增1。</p>
<p>识别当前字符是Backspace时，就让光标右边的字符整体左移一格，然后光标自减。</p>
<p>关键代码如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int len = 0;         // 实际输入长度<br>int cursor = 0;      // 当前光标位置<br>int r;<br>char c;<br><br>    else if (c == 0x7f || c == &#x27;\b&#x27;) &#123;  // Backspace<br>        if (cursor &gt; 0) &#123;<br>            // 1. 删除缓冲区字符<br>            for (int i = cursor - 1; i &lt; len - 1; i++)<br>                buf[i] = buf[i + 1];<br>            len--;<br>            cursor--;<br>            // 2. 打印从当前位置到结尾的字符（覆盖旧内容）<br>            putchar(&#x27;\b&#x27;);               // 移动光标到被删字符位置<br>            for (int i = cursor; i &lt; len; i++)<br>                putchar(buf[i]);<br>            putchar(&#x27; &#x27;);                     // 清除旧的最后一个字符<br>            // 3. 把光标移回原位<br>            for (int i = cursor; i &lt;= len; i++)<br>                putchar(&#x27;\b&#x27;);<br>        &#125;<br>    &#125; else if (c == &#x27;\x1b&#x27;) &#123;  // Escape sequence<br>        char seq[2];<br>        if (read(0, &amp;seq[0], 1) != 1) continue;<br>        if (read(0, &amp;seq[1], 1) != 1) continue;<br>        if (seq[0] == &#x27;[&#x27;) &#123;<br>            if (seq[1] == &#x27;D&#x27;) &#123;  // Left arrow<br>                if (cursor &gt; 0) &#123;<br>                    cursor--;<br>                &#125;<br>            &#125; else if (seq[1] == &#x27;C&#x27;) &#123;  // Right arrow<br>                if (cursor &lt; len) &#123;<br>                    cursor++;<br>                &#125; else &#123;<br>                    <br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure>
<h3 id="不带-b-后缀指令"><a href="#不带-b-后缀指令" class="headerlink" title="不带 .b 后缀指令"></a>不带 .b 后缀指令</h3><p>这一点只需要修改spawn就行，当当前文件打不开时就在文件路径后面加.b再打开以此即可。</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int open_again_with_b(char *prog) &#123;<br>	char temp[256];<br>	int i;<br>	for (i = 0; prog[i] != &#x27;\0&#x27;; ++i) &#123;<br>		temp[i] = prog[i];<br>	&#125;<br>	temp[i++] = &#x27;.&#x27;;<br>	temp[i++] = &#x27;b&#x27;;<br>	temp[i] = &#x27;\0&#x27;;<br>	return open(temp, O_RDONLY);<br>&#125;<br><br>if (((fd = open(prog, O_RDONLY)) &lt; 0) &amp;&amp; ((fd = open_again_with_b(prog)) &lt; 0)) &#123;<br>		return fd;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>同理也只需要修改readline即可</p>
<p>代码大致如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">else if (c == CTRL(&#x27;A&#x27;)) &#123;  // Ctrl-A: Move to beginning<br>    while (cursor &gt; 0) &#123;<br>        putchar(&#x27;\b&#x27;);<br>        cursor--;<br>    &#125;<br>&#125; else if (c == CTRL(&#x27;E&#x27;)) &#123;  // Ctrl-E: Move to end<br>    while (cursor &lt; len) &#123;<br>        putchar(&#x27;\033[C&#x27;);<br>        cursor++;<br>    &#125;<br>&#125; else if (c == CTRL(&#x27;K&#x27;)) &#123;  // Ctrl-K: Kill to end<br>    for (int i = cursor; i &lt; len; i++) &#123;<br>        buf[i] = &#x27;\0&#x27;;<br>        putchar(&#x27; &#x27;);<br>    &#125;<br>    for (int i = cursor; i &lt; len; i++) &#123;<br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    len = cursor;<br>&#125; else if (c == CTRL(&#x27;U&#x27;)) &#123;  // Ctrl-U: Kill from start to cursor<br>    for (int i = 0; i &lt; cursor; i++) &#123;<br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    for (int i = 0; i &lt; cursor; i++) &#123;<br>        putchar(&#x27; &#x27;);<br>    &#125;<br>    for (int i = 0; i &lt; cursor; i++) &#123;<br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    for (int i = 0; i + cursor &lt; len; i++) &#123;<br>        buf[i] = buf[i + cursor];<br>    &#125;<br>    len -= cursor;<br>    cursor = 0;<br>&#125; else if (c == CTRL(&#x27;W&#x27;)) &#123;  // Ctrl-W: Delete previous word<br>    int original = cursor;<br>    // 删除空白<br>    while (cursor &gt; 0 &amp;&amp; (buf[cursor - 1] == &#x27; &#x27; || buf[cursor - 1] == &#x27;\t&#x27;)) &#123;<br>        for (int i = cursor - 1; i &lt; len - 1; i++)<br>            buf[i] = buf[i + 1];<br>        len--;<br>        cursor--;<br>        putchar(&#x27;\b&#x27;); <br>        putchar(&#x27; &#x27;); <br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>    // 删除非空白<br>    while (cursor &gt; 0 &amp;&amp; buf[cursor - 1] != &#x27; &#x27; &amp;&amp; buf[cursor - 1] != &#x27;\t&#x27;) &#123;<br>        for (int i = cursor - 1; i &lt; len - 1; i++)<br>    buf[i] = buf[i + 1];<br>        len--;<br>        cursor--;<br>        putchar(&#x27;\b&#x27;); <br>        putchar(&#x27; &#x27;); <br>        putchar(&#x27;\b&#x27;);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="实现注释功能"><a href="#实现注释功能" class="headerlink" title="实现注释功能"></a>实现注释功能</h3><p>这部分内容比较简单，只需要在runcmd之前遍历一遍指令内容，遇到<code>#</code>就替换为<code>\0</code>即可。</p>
<h3 id="实现一行多指令"><a href="#实现一行多指令" class="headerlink" title="实现一行多指令"></a>实现一行多指令</h3><p>得益于语法树的强大，这部分内容已经在语法树执行过程中完成了。</p>
<h2 id="历史指令"><a href="#历史指令" class="headerlink" title="历史指令"></a>历史指令</h2><p>题目要求我们把指令存在根目录的<code>.mos_history</code>里。</p>
<p>那我们就按照题目要求，在shell创建之初就先打开<code>.mos_history</code>，若不存在就创建一个，若存在则用于初始化内存中的history数组。</p>
<p>同时设立一个全局变量history数组用于在内存中存储最近的20条history。</p>
<p>每当从readline读取一行指令时，就更新一次history数组，并将数组内容全部覆盖写进<code>.mos_history</code>。</p>
<p>同时像识别左右键一样识别上下键，实现指令的切换。</p>
<p>这样我们就完成了历史指令的实现。</p>
<p>关键代码如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">else if (c == &#x27;\x1b&#x27;) &#123;  // Escape sequence<br>    char seq[2];<br>    if (read(0, &amp;seq[0], 1) != 1) continue;<br>    if (read(0, &amp;seq[1], 1) != 1) continue;<br>    if (seq[0] == &#x27;[&#x27;) &#123;<br>        if (seq[1] == &#x27;D&#x27;) &#123;  // Left arrow<br>            if (cursor &gt; 0) &#123;<br>                cursor--;<br>            &#125;<br>        &#125; else if (seq[1] == &#x27;C&#x27;) &#123;  // Right arrow<br>            if (cursor &lt; len) &#123;<br>                cursor++;<br>            &#125; else &#123;<br>                <br>            &#125;<br>        &#125;  else if (seq[1] == &#x27;A&#x27;) &#123;  // Up arrow: prev history<br>            if (index &gt; 0) &#123;<br>                printf(&quot;\033[E&quot;);  // Move cursor to beginning of next line<br>                if (index == num) &#123;<br>                    buf[len] = &#x27;\0&#x27;;<br>                    strcpy(has_typed_in, buf);<br>                &#125;<br>                index--;<br>                // 清除当前行<br>                while (cursor &gt; 0) &#123; putchar(&#x27;\b&#x27;); cursor--; &#125;<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27; &#x27;);<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27;\b&#x27;);<br>                // 复制历史到 buf<br>                strcpy(buf, history[index]);<br>                buf[strlen(buf) - 1] = &#x27;\0&#x27;;//消去历史中的\n <br>                len = strlen(buf);<br>                cursor = len;<br>                // 打印历史命令<br>                putchar(&#x27;$&#x27;);<br>                putchar(&#x27; &#x27;);<br>                for (int i = 0; i &lt; len; i++) putchar(buf[i]);<br>            &#125;<br>        &#125; else if (seq[1] == &#x27;B&#x27;) &#123;  // Down arrow: next history<br>            if (index &lt; num) &#123;<br>                index++;<br>                // 清除当前行<br>                while (cursor &gt; 0) &#123; putchar(&#x27;\b&#x27;); cursor--; &#125;<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27; &#x27;);<br>                for (int i = 0; i &lt; len; i++) putchar(&#x27;\b&#x27;);<br>                // 如果还在历史中，加载，否则加载has_typed_in;<br>                if (index &lt; num) &#123;<br>                    strcpy(buf, history[index]);<br>                    buf[strlen(buf) - 1] = &#x27;\0&#x27;; //消去历史中的\n <br>                    len = strlen(buf);<br>                &#125; else &#123;<br>                    strcpy(buf, has_typed_in);<br>                    len = strlen(buf);<br>                &#125;<br>                cursor = len;<br>                // 打印当前内容<br>            <br>                for (int i = 0; i &lt; len; i++) putchar(buf[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="反引号、追加重定向和条件执行"><a href="#反引号、追加重定向和条件执行" class="headerlink" title="反引号、追加重定向和条件执行"></a>反引号、追加重定向和条件执行</h2><p>这部分是实验cd后第二个比较难的部分</p>
<h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><p>我们发现，这部分内容也在语法树中得到了解决.</p>
<p>首先是词法分析，当我们已经偶数次遇到反引号时，我们就将下一次遇见的反引号的Token类型记为<code>T_Backquote_Open</code>,否则记为<code>T_Backquote_Close</code></p>
<p>然后是语法分析，当我遇见<code>T_Backquote_Open</code>时，进入parse_list的循环调用中，解析一个完整的指令并返回根节点，存储在command节点中。</p>
<p>然后是执行部分，在重定向和command执行前，均先检查是否存在反引号未解析，如果有，则开管道和子进程，先让反引号里的指令执行并输出到管道中，然后从管道中取出输出填补到command的已经标记好的index处。</p>
<p>关键代码如下：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\\词法：<br>    else if (c == &#x27;`&#x27;) &#123;<br>        char value[2];<br>		strcpy(value, &quot;`&quot;);<br>        if (backquote_num%2 == 0) &#123;<br>            t-&gt;type = T_BACKQUOTE_OPEN;<br>        &#125; else &#123;<br>            t-&gt;type = T_BACKQUOTE_CLOSE;<br>        &#125;<br>        backquote_num++;<br>		t-&gt;value = alloc_string(value);<br>		lexer.pos += 1;<br>        //debugf(&quot;backquote!\n&quot;);<br>    &#125;<br>\\语法 （parse_command（）函数）<br>    while (current_token.type == T_WORD || current_token.type == T_BACKQUOTE_OPEN) &#123;<br>        if (current_token.type == T_WORD) &#123;<br>            argv[argc++] = current_token.value;<br>            next_token();   <br>        &#125; else &#123;<br>            next_token();<br>            backquote_ast = parse_list();<br>            if (!accept_token(T_BACKQUOTE_CLOSE)) &#123;<br>                debugf(&quot;parse back quote wrong!\n&quot;);<br>                exit();<br>            &#125;<br>            backquote_index = argc;<br>            argc++;<br>        &#125;<br>    &#125;<br>    <br>\\ 执行<br>void handleBackquote(ASTNode *node) &#123;<br>    char **argv = node-&gt;command.argv;<br>    if (node-&gt;command.backquote_index &gt;= 0) &#123;<br>        int p[2];<br>        if(pipe(p) &lt; 0) &#123;<br>            debugf(&quot;failed to create pipe\n&quot;);<br>            exit();<br>        &#125;<br>        int backquote = fork();<br>        if (backquote &lt; 0) &#123;<br>            debugf(&quot;failed to fork in sh.c\n&quot;);<br>            exit();<br>        &#125; else if (backquote == 0) &#123; // 子进程执行反引号部分<br>            close(p[0]);<br>            dup(p[1], 1);<br>            close(p[1]);<br>            execute_ast(node-&gt;command.backquote, 0);<br>            exit();		<br>        &#125; else &#123; // 父进程处理argv<br>            close(p[1]);<br>            char outbuf[1024];<br>            memset(outbuf, 0, sizeof(outbuf));<br>            int offset = 0;<br>            int read_num = 0;<br>            while((read_num = read(p[0], outbuf + offset, sizeof(outbuf) - offset - 5)) &gt; 0) &#123;<br>                offset += read_num;<br>            &#125;<br>            if (read_num &lt; 0) &#123;<br>                debugf(&quot;error in `\n&quot;);<br>                exit();<br>            &#125;<br>            close(p[0]);<br>            for (int i = strlen(outbuf) - 1; i &gt;= 0; i--) &#123;<br>                if (outbuf[i] == &#x27; &#x27; || outbuf[i] == &#x27;\n&#x27;) &#123;<br>                    outbuf[i] = &#x27;\0&#x27;;<br>                &#125; else &#123;<br>                    break;<br>                &#125;<br>            &#125;<br>            argv[node-&gt;command.backquote_index] = alloc_string(outbuf);<br>        &#125;<br>        node-&gt;command.backquote_index = -1;<br>    &#125;<br>&#125;<br><br>int exec_command_node(ASTNode *node, int in_subshell) &#123;<br>    char **argv = node-&gt;command.argv;<br>    if (argv[0] == NULL) return 0;<br>    //处理反引号<br>    handleBackquote(node);<br>	<br>int exec_redirection_node(ASTNode *node, int in_subshell) &#123;<br>    int fd;<br>    handleBackquote(node-&gt;redirect.child);<br></code></pre></td></tr></table></figure>

<h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>这部分内容也很简单，新增文件打开类型O_APPEEND，，同时在serve_open里支持O_APPEND,将文件的偏移设置为文件大小即可。</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (rq-&gt;req_omode &amp; O_APPEND) &#123;<br>    	ff-&gt;f_fd.fd_offset = ff-&gt;f_file.f_size;<br>    	// debugf(&quot;offset: %d\n&quot;, ff-&gt;f_fd.fd_offset);<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h3><p>这部分内容也和语法树紧密关联，可以看出来，在语法树执行阶段，每一层的执行函数都有返回值，其实这就是我为条件执行留下的通道。</p>
<p>每一层返回子层的返回值，归根结底，最初的返回值就落到了内建指令和外部指令中了。</p>
<p>内建指令部分处理起来比较简单，返回值可以立马得到。</p>
<p>但是外部指令是调用了spawn，开了子进程运行的，所以我们需要在子进程结束前通过某种方式让父进程知道子进程的运行状况。</p>
<p>我们再次利用上万能的进程控制块Env,在控制块里新增属性last_call。</p>
<p>然后新增两个系统调用syscall_set_lastcall和syscall_get_lastcall。</p>
<p>外部指令最终都会在libos.c中的libmain里exit，所以我们做如下修改：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void libmain(int argc, char **argv) &#123;<br>	// set env to point at our env structure in envs[].<br>	env = &amp;envs[ENVX(syscall_getenvid())];<br><br>	// call user main routine<br>	int r = main(argc, argv);<br>	// exit gracefully<br>	//向父进程发送结果。<br>	syscall_set_last_call(r);<br>	exit();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在exec_command_node中捕获返回值并返回即可：</p>
<figure class="hljs highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">   if (is_builtin(argv[0])) &#123;<br>       return run_builtin(argv);<br>   &#125; else &#123;<br>       int child = spawn(argv[0], argv);<br>	if (child &gt;= 0) &#123;<br>		wait(child);<br>	&#125; else &#123;<br>		debugf(&quot;spawn %s: %d\n&quot;, argv[0], child);<br>	&#125;<br>       int r = syscall_get_last_call();<br>       return r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就完成了这次挑战性任务的所有内容！！！！（完结撒花</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一学期的os就这样刷的一下过去了，从最初的懵懵懂懂到写完自己的shell，感觉自己对操作系统的运作流程有了质的飞跃（系统调用和Env获得了MVP!!</p>
<p>在通过自己一点一点的努力下，看到自己的shell成功的运行了起来，内心是无比的开心的，shell的挑战性任务不算简单，但是也是很艰难的完成的，花了很长时间去构想怎么在现有的代码架构上达到新的需求呢，到最后也是选择了重构，收获很多。</p>
<p>至此，经过co和os的拷打，自己也算是体验过了手搓一台具有交互能力的现代计算机了。</p>
<p>最后，感谢老师和助教一学期的辛苦工作！感谢这学期帮助过我的同学以及学长学姐的播客！感谢有os这门课！</p>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/code/" rel="tag"><i class="fas fa-tags"></i>code</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2025/06/14/ooUnit4/" rel="next" title="ooUnit4"><i class="fas fa-angle-left"></i><span class="nav-title">ooUnit4</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
    </div>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/selfish1.jpg" alt="Markus">
  
  <h1 class="author-name">Markus</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">6</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">3</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">2</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#lab6-challenge-shell"><span class="toc-text">lab6_challenge_shell</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">语法分析</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">词法分析</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-text">语法分析</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%91%E6%89%A7%E8%A1%8C"><span class="toc-text">语法树执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%94%AF%E6%8C%81"><span class="toc-text">相对路径支持</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#open-remove"><span class="toc-text">open remove</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#cd%E3%80%81pwd%E5%92%8C%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">cd、pwd和当前工作目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E6%8B%93%E5%B1%95%E6%8C%87%E4%BB%A4"><span class="toc-text">拓展指令</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E8%BE%93%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-text">输入优化</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E6%8C%87%E4%BB%A4%E8%87%AA%E7%94%B1%E8%BE%93%E5%85%A5"><span class="toc-text">指令自由输入</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E4%B8%8D%E5%B8%A6-b-%E5%90%8E%E7%BC%80%E6%8C%87%E4%BB%A4"><span class="toc-text">不带 .b 后缀指令</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%A8%E9%87%8A%E5%8A%9F%E8%83%BD"><span class="toc-text">实现注释功能</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%A1%8C%E5%A4%9A%E6%8C%87%E4%BB%A4"><span class="toc-text">实现一行多指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E5%8E%86%E5%8F%B2%E6%8C%87%E4%BB%A4"><span class="toc-text">历史指令</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#%E5%8F%8D%E5%BC%95%E5%8F%B7%E3%80%81%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">反引号、追加重定向和条件执行</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E5%8F%8D%E5%BC%95%E5%8F%B7"><span class="toc-text">反引号</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">追加重定向</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">条件执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div>
    </div>
    
    
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">Markus</span><span class="year"><i class="far fa-copyright"></i>2024 - 2025</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
